C51 COMPILER V9.60.7.0   COMMUNICATION                                                     10/15/2025 21:46:45 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE COMMUNICATION
OBJECT MODULE PLACED IN ..\Output\communication.obj
COMPILER INVOKED BY: D:\APP\KEIL\MDK\C51\BIN\C51.EXE ..\BSP\Src\communication.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..
                    -\BSP\Inc;..\Core\Inc;..\Driver;..\SYSTEM;..\Emembed\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\communication.lst) TABS(2) 
                    -OBJECT(..\Output\communication.obj)

line level    source

   1          #include "communication.h"
   2          
   3          RS485_2 rs485_2;
   4          RS485_4 rs485_4;
   5          RS485_5 rs485_5;
   6          
   7          /**
   8           * @brief 串口2调用结构体 rs485_2 初始化
   9           *
  10           * @param   
  11           *
  12           * @return  void
  13          **/
  14          void Uart2_Send_Statu_Init( void )
  15          {
  16   1          rs485_2.RX2_rev_end_Flag = 0;
  17   1          rs485_2.TX2_buf[128] = 0;
  18   1          rs485_2.RX2_buf[128] = 0;
  19   1          rs485_2.TX2_send_bytelength = 0;
  20   1          rs485_2.TX2_send_cnt = 0;
  21   1          rs485_2.RX2_rev_timeout = 0;
  22   1          rs485_2.RX2_rev_cnt = 0;
  23   1          //DR_485 = 0;
  24   1      }
  25          
  26          /**
  27           * @brief 串口4调用结构体 rs485_4 初始化
  28           *
  29           * @param   
  30           *
  31           * @return  void
  32          **/
  33          void Uart4_Send_Statu_Init( void )
  34          {
  35   1          rs485_4.RX4_rev_end_Flag = 0;
  36   1          rs485_4.TX4_buf[128] = 0;
  37   1          rs485_4.RX4_buf[128] = 0;
  38   1          rs485_4.TX4_send_bytelength = 0;
  39   1          rs485_4.TX4_send_cnt = 0;
  40   1          rs485_4.RX4_rev_timeout = 0;
  41   1          rs485_4.RX4_rev_cnt = 0;
  42   1          //DR_485 = 0;
  43   1      }
  44          
  45          /**
  46           * @brief 串口5调用结构体 rs485_5 初始化
  47           *
  48           * @param   
  49           *
  50           * @return  void
  51          **/
  52          void Uart5_Send_Statu_Init( void )
  53          {
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     10/15/2025 21:46:45 PAGE 2   

  54   1          rs485_5.RX_rcv_end_Flag = 0;
  55   1          rs485_5.TX_buf[1024] = 0;
  56   1          rs485_5.RX_buf[1024] = 0;
  57   1          rs485_5.TX_send_bytelength = 0;
  58   1          rs485_5.TX_send_cnt = 0;
  59   1          rs485_5.RX_rcv_timeout = 0;
  60   1          rs485_5.RX_rcv_cnt = 0;
  61   1          //DR_485 = 0;
  62   1      }
  63          
  64          /**
  65           * @brief 串口4中断处理函数
  66           *
  67           * @param   
  68           *
  69           * @return  void
  70          **/
  71          void Uart2_RXTX_Isr( void ) interrupt 4 
  72          {   
  73   1      
  74   1          /* 1, 检测到S4TI置1，即发送完毕                       */
  75   1          if( TI0 == 1)          //
  76   1          {
  77   2              /* 2, 软件将S4TI清零，等待发送标志位重置，可继续发送    */
  78   2              TI0 = 0;    
  79   2              Busy2 = 0;   
  80   2              /* 3, 依次将TX2_buf中数据送出（写SBUF0操作即为发送）    */
  81   2              if( download_flag == 0 )
  82   2              {
  83   3                  if( rs485_2.TX2_send_bytelength != 0 )
  84   3                  {
  85   4                      SBUF0 = rs485_2.TX2_buf[rs485_2.TX2_send_cnt++];
  86   4                      rs485_2.TX2_send_bytelength--;
  87   4                  }else
  88   3                  {
  89   4                      rs485_2.TX2_send_cnt = 0;
  90   4                      //DR_485 = 0;
  91   4                  }
  92   3              }
  93   2          }
  94   1          
  95   1          /* 1, 检测到S2RI置1，即接收完毕                       */
  96   1          if( RI0 == 1 )
  97   1          {
  98   2              /* 2, 软件将S2RI清零，等待接收标志位重置，可继续发送    */
  99   2              RI0 = 0;
 100   2      
 101   2              R_u2[R_CN2] = SBUF0;
 102   2          R_OD2 = 1;
 103   2          if(R_CN2<UART2_RX_LENTH-1)
 104   2          {
 105   3            R_CN2++;
 106   3          } 
 107   2          T_O2=5; 
 108   2              
 109   2              /* 3, 判断数据包是否接收完毕                           */
 110   2              if( !rs485_2.RX2_rev_end_Flag )
 111   2              {
 112   3                  /* 4, 数据包大于RX_buf 则从头计数                  */
 113   3                  if( rs485_2.RX2_rev_cnt > 128 )
 114   3                  {
 115   4                      rs485_2.RX2_rev_cnt = 0;
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     10/15/2025 21:46:45 PAGE 3   

 116   4                  }
 117   3      
 118   3                  /* 5, 依次将RX2_buf中数据接收（读S2BUF操作即为接收）*/
 119   3                  rs485_2.RX2_buf[rs485_2.RX2_rev_cnt] = SBUF0;
 120   3                  rs485_2.RX2_rev_cnt++;
 121   3              }
 122   2              /* 6, 重置接收完毕判断时间                              */
 123   2              rs485_2.RX2_rev_timeout = 5;
 124   2          }
 125   1      
 126   1      }
 127          
 128          
 129          /**
 130           * @brief 串口4中断处理函数
 131           *
 132           * @param   
 133           *
 134           * @return  void
 135          **/
 136          void Uart4_TX_Isr() interrupt 10 
 137          {   
 138   1          /* 1, 检测到S4TI置1，即发送完毕                       */
 139   1          if( SCON2T & S4TI )          //
 140   1          {
 141   2              /* 2, 软件将S4TI清零，等待发送标志位重置，可继续发送    */
 142   2              SCON2T &= ~S4TI;    
 143   2              Busy4 = 0;
 144   2              /* 3, 依次将TX4_buf中数据送出（写SBUF0操作即为发送）    */
 145   2              // if( rs485_4.TX4_send_bytelength != 0 )
 146   2              // {
 147   2              //     SBUF2_TX = rs485_4.TX4_buf[rs485_4.TX4_send_cnt++];
 148   2              //     rs485_4.TX4_send_bytelength--;
 149   2              // }else
 150   2              // {
 151   2              //     rs485_4.TX4_send_cnt = 0;
 152   2              //     //DR_485 = 0;
 153   2              // }
 154   2          }
 155   1      }
 156          
 157          // /**
 158          //  * @brief  串口4中断处理函数
 159          //  *
 160          //  * @param   
 161          //  *
 162          //  * @return  void
 163          // **/
 164          // void Uart4_RX_Isr() interrupt 11 
 165          // {   
 166          //         /* 1, 检测到S2RI置1，即接收完毕                       */
 167          //     if( SCON2R & S4RI )
 168          //     {
 169          //         /* 2, 软件将S2RI清零，等待接收标志位重置，可继续发送    */
 170          //         SCON2R &= ~S4RI; 
 171          //         /* 3, 判断数据包是否接收完毕                           */
 172          //         if( !rs485_4.RX4_rev_end_Flag )
 173          //         {
 174          //             /* 4, 数据包大于RX_buf 则从头计数                  */
 175          //             if( rs485_4.RX4_rev_cnt > 128 )
 176          //             {
 177          //                 rs485_4.RX4_rev_cnt = 0;
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     10/15/2025 21:46:45 PAGE 4   

 178          //             }
 179          
 180          //             /* 5, 依次将RX4_buf中数据接收（读S2BUF操作即为接收）*/
 181          //             rs485_4.RX4_buf[rs485_4.RX4_rev_cnt] = SBUF2_RX;
 182          //             rs485_4.RX4_rev_cnt++;
 183          //         }
 184          //         /* 6, 重置接收完毕判断时间                              */
 185          //         rs485_4.RX4_rev_timeout = 5;
 186          //     }
 187          // }
 188          
 189          
 190          /**
 191           * @brief 串口5中断处理函数
 192           *
 193           * @param   
 194           *
 195           * @return  void
 196          **/
 197          void Uart5_TX_Isr() interrupt 12 
 198          {   
 199   1          /* 1, 检测到S4TI置1，即发送完毕                       */
 200   1          if( SCON3T & S5TI )          //
 201   1          {
 202   2              /* 2, 软件将S4TI清零，等待发送标志位重置，可继续发送    */
 203   2              SCON3T &= ~S5TI;     
 204   2              /* 3, 依次将TX_buf中数据送出（写SBUF0操作即为发送）    */
 205   2              if( rs485_5.TX_send_bytelength != 0 )
 206   2              {
 207   3                  SBUF3_TX = rs485_5.TX_buf[rs485_5.TX_send_cnt++];
 208   3                  rs485_5.TX_send_bytelength--;
 209   3              }else
 210   2              {
 211   3                  rs485_5.TX_send_cnt = 0;
 212   3                  TR5 = 0;
 213   3              }
 214   2          }
 215   1      }
 216          
 217          /**
 218           * @brief 串口4中断处理函数
 219           *
 220           * @param   
 221           *
 222           * @return  void
 223          **/
 224          void Uart5_RX_Isr() interrupt 13 
 225          {   
 226   1              /* 1, 检测到S2RI置1，即接收完毕                       */
 227   1          if( SCON3R & S5RI )
 228   1          {
 229   2              /* 2, 软件将S2RI清零，等待接收标志位重置，可继续发送    */
 230   2              SCON3R &= ~S5RI; 
 231   2      
 232   2              /* 3, 判断数据包是否接收完毕                           */
 233   2              if( !rs485_5.RX_rcv_end_Flag )
 234   2              {
 235   3                  /* 4, 数据包大于RX_buf 则从头计数                  */
 236   3                  if( rs485_5.RX_rcv_cnt > 1024 )
 237   3                  {
 238   4                      rs485_5.RX_rcv_cnt = 0;
 239   4                  }
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     10/15/2025 21:46:45 PAGE 5   

 240   3      
 241   3                  /* 5, 依次将RX_buf中数据接收（读S2BUF操作即为接收）*/
 242   3                  rs485_5.RX_buf[rs485_5.RX_rcv_cnt] = SBUF3_RX;
 243   3                  rs485_5.RX_rcv_cnt++;
 244   3              }
 245   2              /* 6, 重置接收完毕判断时间                              */
 246   2              rs485_5.RX_rcv_timeout = 5;
 247   2          }
 248   1      }
 249          
 250          void Tim1_Isr( void ) interrupt 3
 251          {
 252   1          TH1   = (uint8_t)(T0_PERIOD_1MS>>8);
 253   1          TL1   = (uint8_t)T0_PERIOD_1MS;  
 254   1      
 255   1          /* 1, 如果接收未超时                                             */
 256   1          if ( rs485_2.RX2_rev_timeout != 0 )  
 257   1          {
 258   2              rs485_2.RX2_rev_timeout--;
 259   2              /* 2, 如果接收超时                                          */
 260   2              if( rs485_2.RX2_rev_timeout == 0 )  
 261   2              {
 262   3                  if( rs485_2.RX2_rev_cnt > 0 )  
 263   3                  {   
 264   4                       /* 3, 接收完毕标志位亮起并初始化接收缓冲区         */
 265   4                      rs485_2.RX2_rev_end_Flag = 1;    
 266   4                  }
 267   3              }
 268   2          } 
 269   1      
 270   1          //     /* 1, 如果接收未超时                                             */
 271   1          // if ( rs485_4.RX4_rev_timeout != 0 )  
 272   1          // {
 273   1          //     rs485_4.RX4_rev_timeout--;
 274   1          //     /* 2, 如果接收超时                                          */
 275   1          //     if( rs485_4.RX4_rev_timeout == 0 )  
 276   1          //     {
 277   1          //         if( rs485_4.RX4_rev_cnt > 0 )  
 278   1          //         {   
 279   1          //              /* 3, 接收完毕标志位亮起并初始化接收缓冲区         */
 280   1          //             rs485_4.RX4_rev_end_Flag = 1;    
 281   1          //         }
 282   1          //     }
 283   1          // } 
 284   1      
 285   1          /* 1, 如果接收未超时                                             */
 286   1          if ( rs485_5.RX_rcv_timeout != 0 )  
 287   1          {
 288   2              rs485_5.RX_rcv_timeout--;
 289   2              /* 2, 如果接收超时                                          */
 290   2              if( rs485_5.RX_rcv_timeout == 0 )  
 291   2              {
 292   3                  if( rs485_5.RX_rcv_cnt > 0 )  
 293   3                  {   
 294   4                       /* 3, 接收完毕标志位亮起并初始化接收缓冲区         */
 295   4                      rs485_5.RX_rcv_end_Flag = 1;    
 296   4                  }
 297   3              }
 298   2          } 
 299   1      }
 300          
 301          
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     10/15/2025 21:46:45 PAGE 6   

 302          void uart4_send_byte( uint8_t byte )
 303          {
 304   1          SCON3T = 0;
 305   1          SBUF2_TX = byte;
 306   1          while (Busy4);
 307   1          Busy4 = 1;
 308   1          SCON3T = 0x80;
 309   1      }
 310          
 311          void uart4_send_str( uint8_t *str,uint16_t len )
 312          {
 313   1          uint16_t i;
 314   1      
 315   1          for(i=0;i<len;i++)
 316   1          {
 317   2              uart4_send_byte(str[i]);
 318   2          }
 319   1      }
 320          
 321          char putchar(char c)
 322          {
 323   1          uart4_send_byte(c);
 324   1          return c;
 325   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    642    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   2582       5
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
