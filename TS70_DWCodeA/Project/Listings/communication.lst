C51 COMPILER V9.60.7.0   COMMUNICATION                                                     11/07/2025 00:56:35 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE COMMUNICATION
OBJECT MODULE PLACED IN ..\Output\communication.obj
COMPILER INVOKED BY: D:\APP\KEIL\MDK\C51\BIN\C51.EXE ..\BSP\Src\communication.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..
                    -\BSP\Inc;..\Core\Inc;..\Driver;..\SYSTEM;..\Emembed\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\communication.lst) TABS(2) 
                    -OBJECT(..\Output\communication.obj)

line level    source

   1          #include "communication.h"
   2          
   3          RS485_2 rs485_2;
   4          RS485_4 rs485_4;
   5          RS485_5 rs485_5;
   6          
   7          /**
   8           * @brief 串口2调用结构体 rs485_2 初始化
   9           *
  10           * @param   
  11           *
  12           * @return  void
  13          **/
  14          void Uart2_Send_Statu_Init( void )
  15          {
  16   1          rs485_2.rcv_end_flag = 0;
  17   1          rs485_2.send_buf[128] = 0;
  18   1          rs485_2.rcv_buf[128] = 0;
  19   1          rs485_2.send_bytelength = 0;
  20   1          rs485_2.send_cnt = 0;
  21   1          rs485_2.rcv_timeout = 0;
  22   1          rs485_2.rcv_cnt = 0;
  23   1          //DR_485 = 0;
  24   1      }
  25          
  26          /**
  27           * @brief 串口4调用结构体 rs485_4 初始化
  28           *
  29           * @param   
  30           *
  31           * @return  void
  32          **/
  33          void Uart4_Send_Statu_Init( void )
  34          {
  35   1          rs485_4.RX_rcv_end_Flag = 0;
  36   1          rs485_4.TX_buf[128] = 0;
  37   1          rs485_4.RX_buf[128] = 0;
  38   1          rs485_4.TX_send_bytelength = 0;
  39   1          rs485_4.TX_send_cnt = 0;
  40   1          rs485_4.RX_rcv_timeout = 0;
  41   1          rs485_4.RX_rcv_cnt = 0;
  42   1      }
  43          
  44          /**
  45           * @brief 串口5调用结构体 rs485_5 初始化
  46           *
  47           * @param   
  48           *
  49           * @return  void
  50          **/
  51          void Uart5_Send_Statu_Init( void )
  52          {
  53   1          rs485_5.RX_rcv_end_Flag = 0;
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     11/07/2025 00:56:35 PAGE 2   

  54   1          rs485_5.TX_buf[1024] = 0;
  55   1          rs485_5.RX_buf[1024] = 0;
  56   1          rs485_5.TX_send_bytelength = 0;
  57   1          rs485_5.TX_send_cnt = 0;
  58   1          rs485_5.RX_rcv_timeout = 0;
  59   1          rs485_5.RX_rcv_cnt = 0;
  60   1      }
  61          
  62          /**
  63           * @brief 串口4中断处理函数
  64           *
  65           * @param   
  66           *
  67           * @return  void
  68          **/
  69          void Uart2_RXTX_Isr( void ) interrupt 4 
  70          {   
  71   1      
  72   1          /* 1, 检测到S4TI置1，即发送完毕                       */
  73   1          if( TI0 == 1)          //
  74   1          {
  75   2              /* 2, 软件将S4TI清零，等待发送标志位重置，可继续发送    */
  76   2              TI0 = 0;    
  77   2              Busy2 = 0;   
  78   2              /* 3, 依次将send_buf中数据送出（写SBUF0操作即为发送）    */
  79   2              if( download_flag == 0 )
  80   2              {
  81   3                  if( rs485_2.send_bytelength != 0 )
  82   3                  {
  83   4                      SBUF0 = rs485_2.send_buf[rs485_2.send_cnt++];
  84   4                      rs485_2.send_bytelength--;
  85   4                  }else
  86   3                  {
  87   4                      rs485_2.send_cnt = 0;
  88   4                      DR2_485 = 0;
  89   4                  }
  90   3              }
  91   2          }
  92   1          
  93   1          /* 1, 检测到S2RI置1，即接收完毕                       */
  94   1          if( RI0 == 1 )
  95   1          {
  96   2              /* 2, 软件将S2RI清零，等待接收标志位重置，可继续发送    */
  97   2              RI0 = 0;
  98   2      
  99   2              R_u2[R_CN2] = SBUF0;
 100   2          R_OD2 = 1;
 101   2          if(R_CN2<UART2_RX_LENTH-1)
 102   2          {
 103   3            R_CN2++;
 104   3          } 
 105   2          T_O2=5; 
 106   2              
 107   2              /* 3, 判断数据包是否接收完毕                           */
 108   2              if( !rs485_2.rcv_end_flag )
 109   2              {
 110   3                  /* 4, 数据包大于RX_buf 则从头计数                  */
 111   3                  if( rs485_2.rcv_cnt > 128 )
 112   3                  {
 113   4                      rs485_2.rcv_cnt = 0;
 114   4                  }
 115   3      
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     11/07/2025 00:56:35 PAGE 3   

 116   3                  /* 5, 依次将rcv_buf中数据接收（读S2BUF操作即为接收）*/
 117   3                  rs485_2.rcv_buf[rs485_2.rcv_cnt] = SBUF0;
 118   3                  rs485_2.rcv_cnt++;
 119   3              }
 120   2              /* 6, 重置接收完毕判断时间                              */
 121   2              rs485_2.rcv_timeout = 5;
 122   2          }
 123   1      
 124   1      }
 125          
 126          
 127          /**
 128           * @brief 串口4中断处理函数
 129           *
 130           * @param   
 131           *
 132           * @return  void
 133          **/
 134          void Uart4_TX_Isr() interrupt 10 
 135          {   
 136   1          /* 1, 检测到S4TI置1，即发送完毕                       */
 137   1          if( SCON2T & S4TI )          //
 138   1          {
 139   2              /* 2, 软件将S4TI清零，等待发送标志位重置，可继续发送    */
 140   2              SCON2T &= ~S4TI;    
 141   2              //Busy4 = 0;
 142   2              /* 3, 依次将TX_buf中数据送出（写SBUF0操作即为发送）    */
 143   2              if( rs485_4.TX_send_bytelength != 0 )
 144   2              {
 145   3                  SBUF2_TX = rs485_4.TX_buf[rs485_4.TX_send_cnt++];
 146   3                  rs485_4.TX_send_bytelength--;
 147   3              }else
 148   2              {
 149   3                  rs485_4.TX_send_cnt = 0;
 150   3                  TR4 = 0;
 151   3              }
 152   2          }
 153   1      }
 154          
 155          /**
 156           * @brief 串口4中断处理函数
 157           *
 158           * @param   
 159           *
 160           * @return  void
 161          **/
 162          void Uart4_RX_Isr() interrupt 11 
 163          {   
 164   1              /* 1, 检测到S2RI置1，即接收完毕                       */
 165   1          if( SCON2R & S4RI )
 166   1          {
 167   2              /* 2, 软件将S2RI清零，等待接收标志位重置，可继续发送    */
 168   2              SCON2R &= ~S4RI; 
 169   2              /* 3, 判断数据包是否接收完毕                           */
 170   2              if( !rs485_4.RX_rcv_end_Flag )
 171   2              {
 172   3                  /* 4, 数据包大于RX_buf 则从头计数                  */
 173   3                  if( rs485_4.RX_rcv_cnt > 128 )
 174   3                  {
 175   4                      rs485_4.RX_rcv_cnt = 0;
 176   4                  }
 177   3      
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     11/07/2025 00:56:35 PAGE 4   

 178   3                  /* 5, 依次将RX_buf中数据接收（读S2BUF操作即为接收）*/
 179   3                  rs485_4.RX_buf[rs485_4.RX_rcv_cnt] = SBUF2_RX;
 180   3                  rs485_4.RX_rcv_cnt++;
 181   3              }
 182   2              /* 6, 重置接收完毕判断时间                              */
 183   2              rs485_4.RX_rcv_timeout = 5;
 184   2          }
 185   1      }
 186          
 187          
 188          /**
 189           * @brief 串口5中断处理函数
 190           *
 191           * @param   
 192           *
 193           * @return  void
 194          **/
 195          void Uart5_TX_Isr() interrupt 12 
 196          {   
 197   1          /* 1, 检测到S4TI置1，即发送完毕                       */
 198   1          if( SCON3T & S5TI )          //
 199   1          {
 200   2              /* 2, 软件将S4TI清零，等待发送标志位重置，可继续发送    */
 201   2              SCON3T &= ~S5TI;     
 202   2              /* 3, 依次将TX_buf中数据送出（写SBUF0操作即为发送）    */
 203   2              if( rs485_5.TX_send_bytelength != 0 )
 204   2              {
 205   3                  SBUF3_TX = rs485_5.TX_buf[rs485_5.TX_send_cnt++];
 206   3                  rs485_5.TX_send_bytelength--;
 207   3              }else
 208   2              {
 209   3                  rs485_5.TX_send_cnt = 0;
 210   3                  TR5 = 0;
 211   3              }
 212   2          }
 213   1      }
 214          
 215          /**
 216           * @brief 串口4中断处理函数
 217           *
 218           * @param   
 219           *
 220           * @return  void
 221          **/
 222          void Uart5_RX_Isr() interrupt 13 
 223          {   
 224   1              /* 1, 检测到S2RI置1，即接收完毕                       */
 225   1          if( SCON3R & S5RI )
 226   1          {
 227   2              /* 2, 软件将S2RI清零，等待接收标志位重置，可继续发送    */
 228   2              SCON3R &= ~S5RI; 
 229   2      
 230   2              /* 3, 判断数据包是否接收完毕                           */
 231   2              if( !rs485_5.RX_rcv_end_Flag )
 232   2              {
 233   3                  /* 4, 数据包大于RX_buf 则从头计数                  */
 234   3                  if( rs485_5.RX_rcv_cnt > 1024 )
 235   3                  {
 236   4                      rs485_5.RX_rcv_cnt = 0;
 237   4                  }
 238   3      
 239   3                  /* 5, 依次将RX_buf中数据接收（读S2BUF操作即为接收）*/
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     11/07/2025 00:56:35 PAGE 5   

 240   3                  rs485_5.RX_buf[rs485_5.RX_rcv_cnt] = SBUF3_RX;
 241   3                  rs485_5.RX_rcv_cnt++;
 242   3              }
 243   2              /* 6, 重置接收完毕判断时间                              */
 244   2              rs485_5.RX_rcv_timeout = 5;
 245   2          }
 246   1      }
 247          
 248          void Tim1_Isr( void ) interrupt 3
 249          {
 250   1          TH1   = (uint8_t)(T0_PERIOD_1MS>>8);
 251   1          TL1   = (uint8_t)T0_PERIOD_1MS;  
 252   1      
 253   1          /* 1, 如果接收未超时                                             */
 254   1          if ( rs485_2.rcv_timeout != 0 )  
 255   1          {
 256   2              rs485_2.rcv_timeout--;
 257   2              /* 2, 如果接收超时                                          */
 258   2              if( rs485_2.rcv_timeout == 0 )  
 259   2              {
 260   3                  if( rs485_2.rcv_cnt > 0 )  
 261   3                  {   
 262   4                       /* 3, 接收完毕标志位亮起并初始化接收缓冲区         */
 263   4                      rs485_2.rcv_end_flag = 1;    
 264   4                  }
 265   3              }
 266   2          } 
 267   1      
 268   1              /* 1, 如果接收未超时                                             */
 269   1          if ( rs485_4.RX_rcv_timeout != 0 )  
 270   1          {
 271   2              rs485_4.RX_rcv_timeout--;
 272   2              /* 2, 如果接收超时                                          */
 273   2              if( rs485_4.RX_rcv_timeout == 0 )  
 274   2              {
 275   3                  if( rs485_4.RX_rcv_cnt > 0 )  
 276   3                  {   
 277   4                       /* 3, 接收完毕标志位亮起并初始化接收缓冲区         */
 278   4                      rs485_4.RX_rcv_end_Flag = 1;    
 279   4                  }
 280   3              }
 281   2          } 
 282   1      
 283   1          /* 1, 如果接收未超时                                             */
 284   1          if ( rs485_5.RX_rcv_timeout != 0 )  
 285   1          {
 286   2              rs485_5.RX_rcv_timeout--;
 287   2              /* 2, 如果接收超时                                          */
 288   2              if( rs485_5.RX_rcv_timeout == 0 )  
 289   2              {
 290   3                  if( rs485_5.RX_rcv_cnt > 0 )  
 291   3                  {   
 292   4                       /* 3, 接收完毕标志位亮起并初始化接收缓冲区         */
 293   4                      rs485_5.RX_rcv_end_Flag = 1;    
 294   4                  }
 295   3              }
 296   2          } 
 297   1      }
 298          
 299          
 300          // void uart4_send_byte( uint8_t byte )
 301          // {
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     11/07/2025 00:56:35 PAGE 6   

 302          //     SCON2T = 0;
 303          //     SBUF2_TX = byte;
 304          //     while (Busy4);
 305          //     Busy4 = 1;
 306          //     SCON2T = 0x80;
 307          // }
 308          
 309          // void uart4_send_str( uint8_t *str,uint16_t len )
 310          // {
 311          //     uint16_t i;
 312          
 313          //     for(i=0;i<len;i++)
 314          //     {
 315          //         uart4_send_byte(str[i]);
 316          //     }
 317          // }
 318          
 319          // char putchar(char c)
 320          // {
 321          //     uart4_send_byte(c);
 322          //     return c;
 323          // }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    737    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   2585    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
