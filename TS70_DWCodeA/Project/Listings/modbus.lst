C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MODBUS
OBJECT MODULE PLACED IN ..\Output\modbus.obj
COMPILER INVOKED BY: D:\APP\KEIL\MDK\C51\BIN\C51.EXE ..\Emembed\Src\modbus.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\BS
                    -P\Inc;..\Core\Inc;..\Driver;..\SYSTEM;..\Emembed\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\modbus.lst) TABS(2) OBJECT(..\
                    -Output\modbus.obj)

line level    source

   1          #include "modbus.h"
   2          
   3          MODBIS5_INFO modbus5;
   4          MODBIS4_INFO modbus4;
   5          
   6          uint8_t fuyin_flag = 0;
   7          
   8          void Modbus_Event_Uart2( void )
   9          {
  10   1          uint16_t crc,rccrc = 0;
  11   1      
  12   1          /*1.接收完毕                                           */
  13   1          if( rs485_2.rcv_end_flag == 1 )
  14   1          {
  15   2              /*2.清空接收完毕标志位                              */    
  16   2              rs485_2.rcv_end_flag = 0;
  17   2      
  18   2              /*3.CRC校验                                         */
  19   2              crc = MODBUS_CRC16(rs485_2.rcv_buf, rs485_2.rcv_cnt-2);
  20   2              rccrc = (rs485_2.rcv_buf[rs485_2.rcv_cnt-1]) | (rs485_2.rcv_buf[rs485_2.rcv_cnt-2]<<8);
  21   2      
  22   2              /*4.清空接收计数                                    */
  23   2              rs485_2.rcv_cnt = 0; 
  24   2      
  25   2              /*5.CRC校验通过，进行地址域校验                      */
  26   2              if( crc == rccrc )
  27   2              {  
  28   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  29   3                  if( rs485_2.rcv_buf[0] == DFJ_ADDR )    
  30   3                  {
  31   4                      switch ( rs485_2.rcv_buf[1] )
  32   4                      {
  33   5                          case 0x03:
  34   5                              Modbus_Fun03_DFG();
  35   5                              break;  
  36   5      
  37   5                          case 0x04:
  38   5                              Modbus_Fun04_DFG();
  39   5                              break;  
  40   5      
  41   5                          default:
  42   5                              break;
  43   5                      }
  44   4                  }
  45   3              }
  46   2          }
  47   1      }
  48          
  49          void Modbus_Event_Uart4( void )
  50          {
  51   1          uint16_t crc,rccrc = 0;
  52   1      
  53   1          /*1.接收完毕                                           */
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 2   

  54   1          if( rs485_4.RX_rcv_end_Flag == 1 )
  55   1          {
  56   2              /*2.清空接收完毕标志位                              */    
  57   2              rs485_4.RX_rcv_end_Flag = 0;
  58   2      
  59   2              /*3.CRC校验                                         */
  60   2              crc = MODBUS_CRC16(rs485_4.RX_buf, rs485_4.RX_rcv_cnt-2);
  61   2              rccrc = (rs485_4.RX_buf[rs485_4.RX_rcv_cnt-1]) | (rs485_4.RX_buf[rs485_4.RX_rcv_cnt-2]<<8);
  62   2      
  63   2              /*4.清空接收计数                                    */
  64   2              rs485_4.RX_rcv_cnt = 0; 
  65   2      
  66   2              /*5.CRC校验通过，进行地址域校验                      */
  67   2              if( crc == rccrc )
  68   2              {
  69   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  70   3                  if( rs485_4.RX_buf[0] == SP350P_ADDR )
  71   3                  {
  72   4                      switch ( rs485_4.RX_buf[1] )
  73   4                      {
  74   5                          case FUN_03:        Modbus_Fun03_slave2();         break; 
  75   5      
  76   5                              break;  
  77   5      
  78   5                          default:
  79   5                              break;
  80   5                      }
  81   4                  }
  82   3              }
  83   2          }
  84   1      }
  85          
  86          void Modbus_Event_Uart5( void )
  87          {
  88   1          uint16_t crc,rccrc = 0;
  89   1      
  90   1          /*1.接收完毕                                           */
  91   1          if( rs485_5.RX_rcv_end_Flag == 1 )
  92   1          {
  93   2              /*2.CRC校验                                         */
  94   2              crc = MODBUS_CRC16(rs485_5.RX_buf, rs485_5.RX_rcv_cnt-2);
  95   2              rccrc = (rs485_5.RX_buf[rs485_5.RX_rcv_cnt - 2]) | (rs485_5.RX_buf[rs485_5.RX_rcv_cnt - 1] << 8);
  96   2      
  97   2              /*3.CRC校验通过，进行地址域校验                      */
  98   2              if( crc == rccrc )
  99   2              {
 100   3                  /*4.地址域校验通过，进入相应功能函数进行处理      */
 101   3                  if( rs485_5.RX_buf[0] == HANSEN_ADDR )
 102   3                  {
 103   4                      switch ( rs485_5.RX_buf[1] )
 104   4                      {    
 105   5                          case FUN_03:        Modbus_Fun03_slave1();         break; 
 106   5      
 107   5                          case FUN_06:        Modbus_Fun06_slave1();         break; 
 108   5                              
 109   5                          case FUN_16:        Modbus_Fun16_slave1();         break;  
 110   5      
 111   5                          default:                                    break;
 112   5                      }
 113   4                  }
 114   3              }
 115   2              /*5.清空接收计数                                    */
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 3   

 116   2              rs485_5.RX_rcv_cnt = 0; 
 117   2              /*6.清空接收完毕标志位                              */    
 118   2              rs485_5.RX_rcv_end_Flag = 0;
 119   2          }
 120   1      }
 121          
 122          void Modbus_Fun03_DFG( void )
 123          {
 124   1          uint16_t i = 0;
 125   1      
 126   1          uint8_t start_addr_03 = 3;              //Slave reply  DATA1_H address
 127   1      
 128   1          for( i = 0; i < 13; i++)
 129   1          {
 130   2              switch (i)
 131   2              {            
 132   3                  /*  40001   后烘干开关                   */
 133   3                  case 0x00:
 134   3                      mc01.PostDry_switch    = rs485_2.rcv_buf[start_addr_03 + 1];   
 135   3      
 136   3                      break;
 137   3      
 138   3                  /*  40002   后烘干加热温度                   */
 139   3                  case 0x01:
 140   3                      mc01.PostDry_temp = rs485_2.rcv_buf[start_addr_03 + 1];   
 141   3      
 142   3                      break; 
 143   3      
 144   3                  /*  40003   撒粉开关及方向                   */
 145   3                  case 0x02:
 146   3                      mc01.SF_direction = rs485_2.rcv_buf[start_addr_03];   
 147   3                      mc01.SF_switch    = rs485_2.rcv_buf[start_addr_03 + 1];   
 148   3      
 149   3                      break;
 150   3      
 151   3                  /*  40004   撒粉功率                   */
 152   3                  case 0x03:
 153   3                      mc01.SF_level = rs485_2.rcv_buf[start_addr_03 + 1];   
 154   3      
 155   3                      break; 
 156   3      
 157   3                  /*  40005   抖粉开关及方向                */
 158   3                  case 0x04:
 159   3                      mc01.DF_direction = rs485_2.rcv_buf[start_addr_03];   
 160   3                      mc01.DF_switch    = rs485_2.rcv_buf[start_addr_03 + 1];   
 161   3      
 162   3                      break;
 163   3      
 164   3                  /*  40006   抖粉功率              */
 165   3                  case 0x05:
 166   3                      mc01.DF_level = rs485_2.rcv_buf[start_addr_03 + 1];   
 167   3      
 168   3                      break;   
 169   3      
 170   3                  /*  40007   吸风开关              */
 171   3                  case 0x06:
 172   3                      mc01.IW2_switch = rs485_2.rcv_buf[start_addr_03];  
 173   3                      mc01.IW1_switch = rs485_2.rcv_buf[start_addr_03 + 1];   
 174   3      
 175   3                      break;   
 176   3      
 177   3                  /*  40008   冷风开关              */
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 4   

 178   3                  case 0x07:
 179   3                      mc01.CW_switch = rs485_2.rcv_buf[start_addr_03 + 1];   
 180   3      
 181   3                      break; 
 182   3      
 183   3                  /*  40009   收料开关              */
 184   3                  case 0x08:
 185   3                      mc01.MR_switch = rs485_2.rcv_buf[start_addr_03 + 1];   
 186   3      
 187   3                      break; 
 188   3      
 189   3                  /*  40010   保温开关               */
 190   3                  case 0x09:
 191   3                      mc01.Insulation_switch = rs485_2.rcv_buf[start_addr_03 + 1];   
 192   3      
 193   3                      break; 
 194   3      
 195   3                  /*  40011   保温温度              */
 196   3                  case 0x0a:
 197   3                      mc01.Insulation_temp = rs485_2.rcv_buf[start_addr_03 + 1];   
 198   3      
 199   3                      break; 
 200   3      
 201   3                  /*  40012   同步开关              */
 202   3                  case 0x0b:
 203   3                      mc01.sync_switch = rs485_2.rcv_buf[start_addr_03 + 1];   
 204   3      
 205   3                      break; 
 206   3      
 207   3                  /*  40013   总开关               */
 208   3                  case 0x0c:
 209   3                      mc01.power_switch = rs485_2.rcv_buf[start_addr_03 + 1];   
 210   3      
 211   3                      break; 
 212   3      
 213   3                  default:
 214   3                      break;
 215   3              }
 216   2              start_addr_03 += 2;
 217   2          }
 218   1      
 219   1          if( mc01.params_get_flag1 == 1 )
 220   1          {
 221   2              mc01.params_get_flag1 = 0;
 222   2              mc01_parms_init();
 223   2          }
 224   1          
 225   1      }
 226          
 227          void Modbus_Fun04_DFG( void )
 228          {
 229   1          uint16_t i = 0;
 230   1      
 231   1          uint8_t start_addr_04 = 3;              //Slave reply  DATA1_H address
 232   1      
 233   1          for( i = 0; i < 1; i++)
 234   1          {
 235   2              switch (i)
 236   2              {
 237   3                  /*  40001   撒粉开关及方向                   */
 238   3                  case 0x00:  
 239   3                      mc01.th_temp    = ((rs485_2.rcv_buf[start_addr_04] << 8) | (rs485_2.rcv_buf[start_addr_04 
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 5   

             -+ 1]));   
 240   3                      Write_Dgus(0X2104,mc01.th_temp);
 241   3                      break;
 242   3      
 243   3                  default:
 244   3                      break;
 245   3              }
 246   2              start_addr_04 += 2;
 247   2          }
 248   1      }
 249          
 250          void Modbus_Fun03_slave1( void )
 251          {
 252   1          uint16_t i;
 253   1      
 254   1          modbus5.send_val_addr  = 3;                //DATA1 H 位置
 255   1          modbus5.byte_cnt   = (rs485_5.RX_buf[4]<<8 | rs485_5.RX_buf[5]) *2;
 256   1          modbus5.start_addr = rs485_5.RX_buf[2]<<8 | rs485_5.RX_buf[3];
 257   1      
 258   1          rs485_5.TX_buf[0]  = HANSEN_ADDR;                //Addr
 259   1          rs485_5.TX_buf[1]  = FUN_03;                   //Fun
 260   1          rs485_5.TX_buf[2]  = modbus5.byte_cnt;       //Byte Count
 261   1      
 262   1          for( i = modbus5.start_addr; i < modbus5.start_addr + modbus5.byte_cnt/2; i++ )
 263   1          {
 264   2              /*    每次循环前初始化byte_info                       */
 265   2              modbus5.byte_info_H = modbus5.byte_info_L = 0X00;
 266   2              switch (i)
 267   2              {   
 268   3                  /*  x白边              */
 269   3                  case 0x00:  
 270   3                      modbus5.byte_info_H  = (uint8_t)(hansen.addr_0x00 >> 8);
 271   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x00 & 0xFF);
 272   3      
 273   3                      break;
 274   3                  /*  y白边              */
 275   3                  case 0x02:  
 276   3                      modbus5.byte_info_H  = (uint8_t)(hansen.addr_0x02 >> 8);
 277   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x02 & 0xFF);
 278   3      
 279   3                      break;
 280   3      
 281   3                  /*  获取当前主板语言              */
 282   3                  case 0x06:  
 283   3                      modbus5.byte_info_H  = (uint8_t)(hansen.addr_0x06 >> 8);
 284   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x06 & 0xFF); 
 285   3      
 286   3                      break;
 287   3      
 288   3                  /*  获取当前主板语言              */
 289   3                  case 0x10:  
 290   3                      modbus5.byte_info_H  = 0x00;
 291   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x10 & 0xFF); 
 292   3      
 293   3                      break;
 294   3      
 295   3                  /*  获取当前主板语言              */
 296   3                  case 0x0c:  
 297   3                      modbus5.byte_info_H  = 0x00;
 298   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x0c & 0xFF); 
 299   3      
 300   3                      break;
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 6   

 301   3      
 302   3                  /*  马达操作                      */
 303   3                  case 0x20:
 304   3                      modbus5.byte_info_H  = (uint8_t)(hansen.addr_0x20 >> 8);
 305   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x20 & 0xFF);
 306   3      
 307   3                      break;
 308   3      
 309   3                  /*  喷头操作                       */    
 310   3                  case 0x21:
 311   3                      modbus5.byte_info_H  = (uint8_t)(hansen.addr_0x21 >> 8);
 312   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x21 & 0xFF);
 313   3      
 314   3                      break;
 315   3      
 316   3                  /*  喷头强度                  */
 317   3                  case 0x22:    
 318   3                      modbus5.byte_info_H  = (uint8_t)(hansen.addr_0x22 >> 8);
 319   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x22 & 0xFF); 
 320   3      
 321   3                      break;
 322   3      
 323   3                  /*  喷头数量                 */
 324   3                  case 0x23:   
 325   3                      modbus5.byte_info_H  = (uint8_t)(hansen.addr_0x23 >> 8);
 326   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x23 & 0xFF); 
 327   3      
 328   3                      break;
 329   3      
 330   3                  /*  信号                 */
 331   3                  case 0x2d:    
 332   3                      modbus5.byte_info_H  = (uint8_t)(hansen.addr_0x2d >> 8);
 333   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x2d & 0xFF); 
 334   3      
 335   3                      break;
 336   3      
 337   3                  /*  校准图类型                 */
 338   3                  case 0x30:   
 339   3                      modbus5.byte_info_H  = (uint8_t)(hansen.addr_0x30 >> 8);
 340   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x30 & 0xFF); 
 341   3      
 342   3                      break; 
 343   3      
 344   3                  default:
 345   3                      break;
 346   3              }
 347   2              rs485_5.TX_buf[modbus5.send_val_addr++] = modbus5.byte_info_H;
 348   2              rs485_5.TX_buf[modbus5.send_val_addr++] = modbus5.byte_info_L;
 349   2          }
 350   1          slave1_to_master(0x03,3 + modbus5.byte_cnt);
 351   1          if( hansen.connect_flag == 0 )
 352   1          {
 353   2              hansen.connect_flag = 1;
 354   2              Write_Dgus(0x2025,1);
 355   2          }
 356   1          
 357   1      }
 358          
 359          void Modbus_Fun06_slave1( void )
 360          {
 361   1          switch(rs485_5.RX_buf[3])
 362   1          {
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 7   

 363   2              /*  马达操作                      */
 364   2              case 0x20:                         
 365   2                  hansen.addr_0x20 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 366   2      
 367   2                  break;  
 368   2      
 369   2              /*  喷头操作                       */    
 370   2              case 0x21:
 371   2                  hansen.addr_0x21 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 372   2      
 373   2                  break;
 374   2      
 375   2              /*  喷头强度                  */
 376   2              case 0x22:    
 377   2                  hansen.addr_0x22 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 378   2      
 379   2                  break;
 380   2      
 381   2              /*  喷头数量                 */
 382   2              case 0x23:   
 383   2                  hansen.addr_0x23 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 384   2      
 385   2                  break;
 386   2      
 387   2              /*  信号                 */
 388   2              case 0x2d:    
 389   2                  hansen.addr_0x2d = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 390   2      
 391   2                  break;
 392   2      
 393   2              /*  校准图类型                 */
 394   2              case 0x30:   
 395   2                  hansen.addr_0x30 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 396   2      
 397   2                  break;
 398   2      
 399   2              // /*                    */
 400   2              // case 0x100:   
 401   2              //     //hansen.addr_0x2 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 402   2      
 403   2              //     break;
 404   2      
 405   2              // /*                    */
 406   2              // case 0x101:    
 407   2              //     //hansen.addr_0x24 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 408   2      
 409   2              //     break;
 410   2       
 411   2              // /*                    */
 412   2              // case 0x102:   
 413   2              //     //hansen.addr_0x25 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 414   2      
 415   2              //     break;
 416   2      
 417   2              default:
 418   2                  break;   
 419   2          }
 420   1      
 421   1          slave1_to_master(FUN_06,8);
 422   1      
 423   1      }
 424          
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 8   

 425          /**
 426           * @brief 写多个输出寄存器  16
 427           *
 428           * @param   void
 429           *
 430           * @return  void 
 431          **/
 432          void Modbus_Fun16_slave1( void )
 433          {
 434   1          uint16_t i;
 435   1          static uint8_t chip_id[32] = {0};
 436   1          static uint8_t FW_set[32] = {0};
 437   1          static uint8_t FW_params[32] = {0};
 438   1          static uint8_t HS_version[30] = {0};
 439   1          static uint8_t renwu_name[32] = {0};
 440   1          static uint8_t dayin_mode[20] = {0};
 441   1      
 442   1          modbus5.rcv_value_addr = 7;                  //DATA1 H位置
 443   1          modbus5.byte_cnt   = rs485_5.RX_buf[6];
 444   1          modbus5.start_addr = rs485_5.RX_buf[2]<<8 | rs485_5.RX_buf[3];
 445   1      
 446   1          for( i = modbus5.start_addr; i < modbus5.start_addr + modbus5.byte_cnt/2; i++)
 447   1          {
 448   2              modbus5.byte_info_H = rs485_5.RX_buf[modbus5.rcv_value_addr];
 449   2              modbus5.byte_info_L = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 450   2              switch (i)
 451   2              {
 452   3                  
 453   3                  /*  0x0100  系统动作    */
 454   3                  case 0x0100:
 455   3                      hansen.addr_0x0100 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 456   3      
 457   3                      switch(hansen.addr_0x0100)
 458   3                      {
 459   4                          
 460   4                          case 0:         hansen.addr_0x20 = 0;   fuyin_flag = 0;                               
             -break;      //清除跑机使能    
 461   4                          case 2:         hansen.addr_0x20 = 0;   Write_Dgus(0x2020,0);                         
             -break;      //清除马达操作使能 
 462   4                          case 3:         hansen.addr_0x30 = 0;                                                 
             -break;      //清除检测使能       
 463   4                          case 6:         hansen.addr_0x21 = 0;   hansen.addr_0x22 = 0;   hansen.addr_0x23 = 0; 
             -break;      //清除清洗、装墨使能         
 464   4                          case 10:        hansen.addr_0x21 = 0;   hansen.addr_0x23 = 0;                         
             -break;      //开始装墨
 465   4                          case 12:        hansen.addr_0x20 = 0;                                                 
             -break;      //开始装墨
 466   4                          default:                                                                              
             -break;      //清除跑机使能      
 467   4                      }
 468   3      
 469   3                      break;
 470   3      
 471   3                  /*  0x0102  打印状态    */
 472   3                  case 0x0102:
 473   3                      hansen.addr_0x0102 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 474   3      
 475   3                      switch(hansen.addr_0x0102)
 476   3                      { 
 477   4                          case 0:         Write_Dgusii_Vp_byChar(0x1600,"  空闲  ",8); 
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 9   

 478   4                                          hansen.addr_0x2d = 0;
 479   4                                          if( hansen.ctrl_flag == 0 )
 480   4                                          {
 481   5                                              hansen.ctrl_flag = 1;
 482   5                                              jump_page(0);
 483   5                                          }     
 484   4                                          break;
 485   4                          case 1:         if( hansen.ctrl_flag == 0 )
 486   4                                          {
 487   5                                              Write_Dgusii_Vp_byChar(0x1600," 初始化 ",8);
 488   5                                          }
 489   4                                          break;     
 490   4                          case 2:         Write_Dgusii_Vp_byChar(0x1600,"  打印  ",8);       
 491   4                                          if( fuyin_flag == 0 )
 492   4                                          { 
 493   5                                              jump_page(11); 
 494   5                                          } 
 495   4                                          break;
 496   4                          case 3:         Write_Dgusii_Vp_byChar(0x1600,"  恢复  ",8);        break;     
 497   4                          case 4:         Write_Dgusii_Vp_byChar(0x1600,"  暂停  ",8);        break;
 498   4                          case 6:         Write_Dgusii_Vp_byChar(0x1600,"  保湿  ",8);        break;    
 499   4                          case 7:         Write_Dgusii_Vp_byChar(0x1600,"其他动作",8);        break;
 500   4                          default:                                                            break;
 501   4                      }
 502   3      
 503   3                      break;
 504   3      
 505   3                  /*  0x0110  总打印份数    */
 506   3                  case 0x0110:
 507   3                      hansen.addr_0x0110 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1]; 
 508   3                      Write_Dgus(0x20ce,hansen.addr_0x0110);   
 509   3                      break;
 510   3      
 511   3                  /*  0x0111  当前打印份数/打印幅数    */    
 512   3                  case 0x0111:
 513   3                      hansen.addr_0x0111 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1]; 
 514   3                      Write_Dgus(0x20cd,hansen.addr_0x0111); 
 515   3                      break;
 516   3      
 517   3                  /*  0x0112  打印精度(XDPI)    */
 518   3                  case 0x0112:
 519   3                      hansen.addr_0x0112 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1]; 
 520   3                      Write_Dgus(0x20c0,hansen.addr_0x0112); 
 521   3                      break;   
 522   3      
 523   3                  /*  0x0114  打印精度(YDPI)    */    
 524   3                  case 0x0114:
 525   3                      hansen.addr_0x0114 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1]; 
 526   3                      Write_Dgus(0x20c2,hansen.addr_0x0114); 
 527   3                      break; 
 528   3      
 529   3                  /*  0x011A  图像宽度（mm）    */  
 530   3                  case 0x011a:
 531   3                      hansen.addr_0x011a = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1]; 
 532   3                      Write_Dgus(0x20c4,hansen.addr_0x011a); 
 533   3                      break;
 534   3      
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 10  

 535   3                  /*  0x011C  图像高度（mm）    */   
 536   3                  case 0x011c:
 537   3                      hansen.addr_0x011c = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1]; 
 538   3                      Write_Dgus(0x20c6,hansen.addr_0x011c); 
 539   3                      break;
 540   3      
 541   3                  /*  0x0120~124  打印模式    */     
 542   3                  case 0x0120:
 543   3                      dayin_mode[0] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 544   3                      dayin_mode[1] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 545   3                      break;
 546   3                  case 0x0121:
 547   3                      dayin_mode[2] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 548   3                      dayin_mode[3] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 549   3                      break;
 550   3                  case 0x0122:
 551   3                      dayin_mode[4] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 552   3                      dayin_mode[5] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 553   3                      break;
 554   3                  case 0x0123:
 555   3                      dayin_mode[6] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 556   3                      dayin_mode[7] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 557   3                      break;
 558   3                  case 0x0124:
 559   3                      dayin_mode[8] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 560   3                      dayin_mode[9] = rs485_5.RX_buf[modbus5.rcv_value_addr]; 
 561   3                      Write_Dgusii_Vp_byChar(0x20b0,dayin_mode,10);           
 562   3                      break;
 563   3      
 564   3                  /*  0x0134  打印计时-秒    */   
 565   3                  case 0x0134:
 566   3                      hansen.addr_0x0134 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 567   3                      time_trans(hansen.addr_0x0134,0);
 568   3      
 569   3                      Write_Dgus(0x20d0,dayin_t.cnt_h); 
 570   3                      Write_Dgus(0x20d1,dayin_t.cnt_min); 
 571   3                      Write_Dgus(0x20d2,dayin_t.cnt_s); 
 572   3                      break;
 573   3                  
 574   3                  /*  0x0136  剩余时间-秒    */    
 575   3                  case 0x0136:
 576   3                      hansen.addr_0x0136 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 577   3                      time_trans(hansen.addr_0x0136,1);
 578   3      
 579   3                      Write_Dgus(0x20d3,dayin_t.remain_h); 
 580   3                      Write_Dgus(0x20d4,dayin_t.remain_min); 
 581   3                      Write_Dgus(0x20d5,dayin_t.remain_s); 
 582   3                      break;
 583   3      
 584   3                  /*  0x0138  打印产能(面积)    */        
 585   3                  case 0x0138:
 586   3                      hansen.addr_0x0138 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 587   3      
 588   3                      Write_Dgus(0x20cc,hansen.addr_0x0138); 
 589   3                      break;
 590   3      
 591   3                  /*  0x013A  打印产能(长度)    */ 
 592   3                  case 0x013a:
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 11  

 593   3                      hansen.addr_0x013a = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 594   3      
 595   3                      Write_Dgus(0x20c9,hansen.addr_0x013a); 
 596   3                      break;
 597   3      
 598   3                  /*  0x013C  打印产能(长度)    */ 
 599   3                  case 0x013c:
 600   3                      hansen.addr_0x013c = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 601   3                      if( hansen.addr_0x013c == 100 )
 602   3                      {
 603   4                          jump_page(0); 
 604   4                      }
 605   3                      Write_Dgus(0x20d9,hansen.addr_0x013c); 
 606   3                      break;
 607   3      
 608   3                  /*  0x0140~149  PRN任务名称    */    
 609   3                  case 0x0140:
 610   3                      renwu_name[0] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 611   3                      renwu_name[1] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 612   3                      break;
 613   3                  case 0x0141:
 614   3                      renwu_name[2] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 615   3                      renwu_name[3] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 616   3                      break;
 617   3                  case 0x0142:
 618   3                      renwu_name[4] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 619   3                      renwu_name[5] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 620   3                      break;
 621   3                  case 0x0143:
 622   3                      renwu_name[6] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 623   3                      renwu_name[7] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 624   3                      break;
 625   3                  case 0x0144:
 626   3                      renwu_name[8] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 627   3                      renwu_name[9] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 628   3                      break;
 629   3                  case 0x0145:
 630   3                      renwu_name[10] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 631   3                      renwu_name[11] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 632   3                      break;
 633   3                  case 0x0146:
 634   3                      renwu_name[12] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 635   3                      renwu_name[13] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 636   3                      break;
 637   3                  case 0x0147:
 638   3                      renwu_name[14] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 639   3                      renwu_name[15] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 640   3                      break;
 641   3                  case 0x0148:
 642   3                      renwu_name[16] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 643   3                      renwu_name[17] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 644   3                      break;
 645   3                  case 0x0149:
 646   3                      renwu_name[18] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 647   3                      renwu_name[19] = rs485_5.RX_buf[modbus5.rcv_value_addr];     
 648   3                      //Write_Dgusii_Vp_byChar(0x20f0,renwu_name,20);   
 649   3                      break;
 650   3                  
 651   3                  /*  0x0150~151  X马达位置    */ 
 652   3                  case 0x0150:
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 12  

 653   3                      hansen.addr_0x0150 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 654   3                      break;
 655   3                  case 0x0151:
 656   3                      hansen.addr_0x0151 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 657   3                      Write_Dgus(0x2070,hansen.addr_0x0151);
 658   3                      Write_Dgus(0x2071,hansen.addr_0x0150);
 659   3                      break;
 660   3      
 661   3                  /*  0x0152~153  Y马达位置    */     
 662   3                  case 0x0152:
 663   3                      hansen.addr_0x0152 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 664   3                      break;
 665   3                  case 0x0153:
 666   3                      hansen.addr_0x0153 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 667   3                      // Write_Dgus(0x2072,hansen.addr_0x0153);
 668   3                      // Write_Dgus(0x2073,hansen.addr_0x0152);
 669   3                      break;
 670   3      
 671   3                  /*  0x0154~155  Z马达位置    */     
 672   3                  case 0x0154:
 673   3                      hansen.addr_0x0154 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 674   3                      break;
 675   3                  case 0x0155:
 676   3                      hansen.addr_0x0155 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 677   3                      // Write_Dgus(0x2074,hansen.addr_0x0155);
 678   3                      // Write_Dgus(0x2075,hansen.addr_0x0154);
 679   3                      break;
 680   3      
 681   3                  /*  0x0156~157  主板IP    */ 
 682   3                  case 0x0156:
 683   3                      hansen.addr_0x0156_H = rs485_5.RX_buf[modbus5.rcv_value_addr];
 684   3                      hansen.addr_0x0156_L = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 685   3                      break;
 686   3                  case 0x0157:
 687   3                      hansen.addr_0x0157_H = rs485_5.RX_buf[modbus5.rcv_value_addr];
 688   3                      hansen.addr_0x0157_L = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 689   3                      Write_Dgus(0x2080,hansen.addr_0x0156_L);     
 690   3                      Write_Dgus(0x2082,hansen.addr_0x0156_H);    
 691   3                      Write_Dgus(0x2084,hansen.addr_0x0157_L);     
 692   3                      Write_Dgus(0x2086,hansen.addr_0x0157_H);    
 693   3                      break;
 694   3      
 695   3                  /*  0x0158  X白边    */ 
 696   3                  case 0x0158:
 697   3                      hansen.addr_0x00 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus5.
             -rcv_value_addr + 1];
 698   3                      Write_Dgus(0x2060,hansen.addr_0x00);     
 699   3                      break;
 700   3      
 701   3                  /*  0x015A  Y白边    */ 
 702   3                  case 0x015a:
 703   3                      hansen.addr_0x02 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus5.
             -rcv_value_addr + 1];
 704   3                      Write_Dgus(0x2062,hansen.addr_0x02);  
 705   3                      break;
 706   3      
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 13  

 707   3                  /*  0x015E  打印设置    */ 
 708   3                  case 0x015e:
 709   3                      hansen.addr_0x06 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus5.
             -rcv_value_addr + 1];
 710   3                      
 711   3                      hansen.addr_0x06_02 = hansen.addr_0x06 & 0x04;
 712   3      
 713   3                      hansen.addr_0x06_35 = (hansen.addr_0x06 & 0x38) >> 3;
 714   3      
 715   3                      hansen.addr_0x06_67 = (hansen.addr_0x06 & 0xc0) >> 6;
 716   3                      if( hansen.addr_0x06_67 == 3 )
 717   3                      {
 718   4                          hansen.addr_0x06_67 = 4;
 719   4                      }
 720   3      
 721   3                      hansen.addr_0x06_8a = (hansen.addr_0x06 & 0x0700) >> 8;
 722   3      
 723   3                      hansen.addr_0x06_bc = (hansen.addr_0x06 & 0x1800) >> 11;
 724   3                      hansen.addr_0x06_bc = 0x01 << hansen.addr_0x06_bc;
 725   3      
 726   3                      Write_Dgus(0x2051,hansen.addr_0x06_02);  
 727   3                      Write_Dgus(0x2052,hansen.addr_0x06_35);
 728   3                      Write_Dgus(0x2053,hansen.addr_0x06_67);
 729   3                      Write_Dgus(0x2054,hansen.addr_0x06_8a);    
 730   3                      Write_Dgus(0x2055,hansen.addr_0x06_bc);   
 731   3                      break;
 732   3      
 733   3                  /*  0x015F  羽化幅度    */     
 734   3                  case 0x015f:
 735   3                      hansen.addr_yuhua = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus5
             -.rcv_value_addr + 1];
 736   3      
 737   3                      break;
 738   3      
 739   3                  /*  0x015F  当前实际喷头个数    */     
 740   3                  case 0x0160:
 741   3                      hansen.addr_sjpt = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus5.
             -rcv_value_addr + 1];
 742   3      
 743   3                      break;
 744   3      
 745   3                  /*  0x0161  当前清洗类型    */     
 746   3                  case 0x0161:
 747   3                      hansen.addr_0x22 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus5.
             -rcv_value_addr + 1];
 748   3      
 749   3                      Write_Dgus(0x2022,hansen.addr_0x22);
 750   3                      hansen.addr_0x22 = 0;    
 751   3                      break;
 752   3      
 753   3                  /*  0x0162  当前清洗/装墨喷头个数    */     
 754   3                  case 0x0162:
 755   3                      hansen.addr_0x23 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus5.
             -rcv_value_addr + 1];
 756   3                      Write_Dgus(0x2023,hansen.addr_0x23);
 757   3                      hansen.addr_0x23 = 0;  
 758   3                      break;
 759   3      
 760   3                  
 761   3                  /*  40007  同步开关设置                         */
 762   3                  case 0x0169:
 763   3                      hansen.addr_0x0169 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 14  

             -5.rcv_value_addr + 1];
 764   3      
 765   3                      switch(hansen.addr_0x0169)
 766   3                      {
 767   4                          
 768   4                          case 0  :         hansen.addr_0x10 |= 0x20;           break;         
 769   4                          
 770   4                          default:                                            break;
 771   4                      }
 772   3      
 773   3                      break;
 774   3      
 775   3                  case 0x0170:
 776   3                      HS_version[0] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 777   3                      HS_version[1] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 778   3                      break;
 779   3                  case 0x0171:
 780   3                      HS_version[2] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 781   3                      HS_version[3] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 782   3                      break;
 783   3                  case 0x0172:
 784   3                      HS_version[4] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 785   3                      HS_version[5] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 786   3                      break;
 787   3                  case 0x0173:
 788   3                      HS_version[6] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 789   3                      HS_version[7] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 790   3                      break;
 791   3                  case 0x0174:
 792   3                      HS_version[8] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 793   3                      HS_version[9] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 794   3                      break;
 795   3                  case 0x0175:
 796   3                      HS_version[10] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 797   3                      HS_version[11] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 798   3                      break;
 799   3      
 800   3                  case 0x0176:
 801   3                      HS_version[12] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 802   3                      HS_version[13] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 803   3                      break;
 804   3                  case 0x0177:
 805   3                      HS_version[14] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 806   3                      HS_version[15] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 807   3                      break;
 808   3                  case 0x0178:
 809   3                      HS_version[16] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 810   3                      HS_version[17] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 811   3                      break;
 812   3                  case 0x0179:
 813   3                      HS_version[18] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 814   3                      HS_version[19] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 815   3                      break;
 816   3                  case 0x017a:
 817   3                      HS_version[20] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 818   3                      HS_version[21] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 819   3                      break;
 820   3                  case 0x017b:
 821   3                      HS_version[22] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 822   3                      HS_version[23] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 823   3                      break;
 824   3                  case 0x017c:
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 15  

 825   3                      HS_version[24] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 826   3                      HS_version[25] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 827   3                      break;
 828   3                  case 0x017d:
 829   3                      HS_version[26] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 830   3                      HS_version[27] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 831   3                      break;
 832   3      
 833   3                  case 0x017e:
 834   3                      HS_version[28] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 835   3                      HS_version[29] = rs485_5.RX_buf[modbus5.rcv_value_addr];   
 836   3                      Write_Dgusii_Vp_byChar(0x1630,HS_version,30);       
 837   3                      break;
 838   3      
 839   3                  case 0x0190:
 840   3                      chip_id[0] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 841   3                      chip_id[1] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 842   3                      break;
 843   3                  case 0x0191:
 844   3                      chip_id[2] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 845   3                      chip_id[3] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 846   3                      break;
 847   3                  case 0x0192:
 848   3                      chip_id[4] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 849   3                      chip_id[5] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 850   3                      break;
 851   3                  case 0x0193:
 852   3                      chip_id[6] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 853   3                      chip_id[7] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 854   3                      break;
 855   3                  case 0x0194:
 856   3                      chip_id[8] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 857   3                      chip_id[9] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 858   3                      break;
 859   3                  case 0x0195:
 860   3                      chip_id[10] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 861   3                      chip_id[11] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 862   3                      break;
 863   3      
 864   3                  case 0x0196:
 865   3                      chip_id[12] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 866   3                      chip_id[13] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 867   3                      break;
 868   3                  case 0x0197:
 869   3                      chip_id[14] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 870   3                      chip_id[15] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 871   3                      break;
 872   3                  case 0x0198:
 873   3                      chip_id[16] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 874   3                      chip_id[17] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 875   3                      break;
 876   3                  case 0x0199:
 877   3                      chip_id[18] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 878   3                      chip_id[19] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 879   3                      break;
 880   3                  case 0x019a:
 881   3                      chip_id[20] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 882   3                      chip_id[21] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 883   3                      break;
 884   3                  case 0x019b:
 885   3                      chip_id[22] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 886   3                      chip_id[23] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 16  

 887   3                      break;
 888   3                  case 0x019c:
 889   3                      chip_id[24] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 890   3                      chip_id[25] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 891   3                      break;
 892   3                  case 0x019d:
 893   3                      chip_id[26] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 894   3                      chip_id[27] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 895   3                      break;
 896   3      
 897   3                  case 0x019e:
 898   3                      chip_id[28] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 899   3                      chip_id[29] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 900   3                      break;
 901   3                  case 0x019f:
 902   3                      chip_id[30] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 903   3                      chip_id[31] = rs485_5.RX_buf[modbus5.rcv_value_addr];
 904   3                      Write_Dgusii_Vp_byChar(0x1650,chip_id,32);   
 905   3                      break;
 906   3      
 907   3                  case 0x01c0:
 908   3                      FW_set[0] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 909   3                      FW_set[1] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 910   3                      break;
 911   3                  case 0x01C1:
 912   3                      FW_set[2] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 913   3                      FW_set[3] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 914   3                      break;
 915   3                  case 0x01C2:
 916   3                      FW_set[4] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 917   3                      FW_set[5] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 918   3                      break;
 919   3                  case 0x01C3:
 920   3                      FW_set[6] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 921   3                      FW_set[7] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 922   3                      break;
 923   3                  case 0x01C4:
 924   3                      FW_set[8] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 925   3                      FW_set[9] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 926   3                      break;
 927   3                  case 0x01C5:
 928   3                      FW_set[10] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 929   3                      FW_set[11] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 930   3                      break;
 931   3      
 932   3                  case 0x01C6:
 933   3                      FW_set[12] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 934   3                      FW_set[13] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 935   3                      break;
 936   3                  case 0x01C7:
 937   3                      FW_set[14] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 938   3                      FW_set[15] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 939   3                      break;
 940   3                  case 0x01C8:
 941   3                      FW_set[16] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 942   3                      FW_set[17] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 943   3                      break;
 944   3                  case 0x01C9:
 945   3                      FW_set[18] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 946   3                      FW_set[19] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 947   3                      break;
 948   3                  case 0x01Ca:
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 17  

 949   3                      FW_set[20] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 950   3                      FW_set[21] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 951   3                      break;
 952   3                  case 0x01Cb:
 953   3                      FW_set[22] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 954   3                      FW_set[23] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 955   3                      break;
 956   3                  case 0x01Cc:
 957   3                      FW_set[24] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 958   3                      FW_set[25] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 959   3                      break;
 960   3                  case 0x01Cd:
 961   3                      FW_set[26] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 962   3                      FW_set[27] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 963   3                      break;
 964   3      
 965   3                  case 0x01Ce:
 966   3                      FW_set[28] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 967   3                      FW_set[29] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 968   3                      break;
 969   3                  case 0x01Cf:
 970   3                      FW_set[30] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 971   3                      FW_set[31] = rs485_5.RX_buf[modbus5.rcv_value_addr];
 972   3                      Write_Dgusii_Vp_byChar(0x1670,FW_set,32);   
 973   3                      break;
 974   3      
 975   3                  case 0x01D0:
 976   3                      FW_params[0] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 977   3                      FW_params[1] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 978   3                      break;
 979   3                  case 0x01D1:
 980   3                      FW_params[2] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 981   3                      FW_params[3] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 982   3                      break;
 983   3                  case 0x01D2:
 984   3                      FW_params[4] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 985   3                      FW_params[5] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 986   3                      break;
 987   3                  case 0x01D3:
 988   3                      FW_params[6] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 989   3                      FW_params[7] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 990   3                      break;
 991   3                  case 0x01D4:
 992   3                      FW_params[8] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 993   3                      FW_params[9] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 994   3                      break;
 995   3                  case 0x01D5:
 996   3                      FW_params[10] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 997   3                      FW_params[11] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 998   3                      break;
 999   3      
1000   3                  case 0x01D6:
1001   3                      FW_params[12] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
1002   3                      FW_params[13] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
1003   3                      break;
1004   3                  case 0x01D7:
1005   3                      FW_params[14] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
1006   3                      FW_params[15] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
1007   3                      break;
1008   3                  case 0x01D8:
1009   3                      FW_params[16] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
1010   3                      FW_params[17] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 18  

1011   3                      break;
1012   3                  case 0x01D9:
1013   3                      FW_params[18] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
1014   3                      FW_params[19] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
1015   3                      break;
1016   3                  case 0x01Da:
1017   3                      FW_params[20] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
1018   3                      FW_params[21] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
1019   3                      break;
1020   3                  case 0x01Db:
1021   3                      FW_params[22] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
1022   3                      FW_params[23] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
1023   3                      break;
1024   3                  case 0x01Dc:
1025   3                      FW_params[24] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
1026   3                      FW_params[25] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
1027   3                      break;
1028   3                  case 0x01Dd:
1029   3                      FW_params[26] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
1030   3                      FW_params[27] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
1031   3                      break;
1032   3      
1033   3                  case 0x01De:
1034   3                      FW_params[28] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
1035   3                      FW_params[29] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
1036   3                      break;
1037   3                  case 0x01Df:
1038   3                      FW_params[30] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
1039   3                      FW_params[31] = rs485_5.RX_buf[modbus5.rcv_value_addr];
1040   3                      Write_Dgusii_Vp_byChar(0x1690,FW_params,32);   
1041   3                      break;    
1042   3                  default:
1043   3                      break;
1044   3              }
1045   2              modbus5.rcv_value_addr += 2;         //从Value1_H →→ 从Value2_H
1046   2          }
1047   1          
1048   1          slave1_to_master(FUN_16,8);  
1049   1      }
1050          
1051          
1052          void Modbus_Fun03_slave2( void )
1053          {
1054   1          uint16_t i = 0;
1055   1      
1056   1          uint8_t start_addr_03 = 3;              //Slave reply  DATA1_H address
1057   1      
1058   1          for( i = 0; i < 9; i++)
1059   1          {
1060   2              switch (i)
1061   2              {
1062   3      
1063   3                  /*  40001 三路220V输出使能设置          */
1064   3                  case 0x00:
1065   3                      sp350.F_switch = rs485_4.RX_buf[start_addr_03 + 1];   
1066   3      
1067   3                      break;
1068   3      
1069   3                  /*  40002   风速12设置                   */
1070   3                  case 0x01:
1071   3                      sp350.M_switch = rs485_4.RX_buf[start_addr_03 + 1];   
1072   3      
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 19  

1073   3                      break;
1074   3      
1075   3                  /*  40003   风速3设置                   */
1076   3                  case 0x02:
1077   3                      sp350.R_switch = rs485_4.RX_buf[start_addr_03 + 1];   
1078   3      
1079   3                      break; 
1080   3      
1081   3                  /*  40004   同步状态设置                */
1082   3                  case 0x03:
1083   3                      sp350.F_alarm_val = rs485_4.RX_buf[start_addr_03 + 1];   
1084   3      
1085   3                      break;
1086   3      
1087   3                  /*  40005   预加热开关              */
1088   3                  case 0x04:
1089   3                      sp350.M_alarm_val = rs485_4.RX_buf[start_addr_03 + 1];   
1090   3      
1091   3                      break;   
1092   3      
1093   3                  /*  40006   预加热温度设置              */
1094   3                  case 0x05:
1095   3                      sp350.R_alarm_val = rs485_4.RX_buf[start_addr_03 + 1];   
1096   3      
1097   3                      break;   
1098   3      
1099   3                  /*  40007   预加热时间设置              */
1100   3                  case 0x06:
1101   3                      sp350.LED_switch = rs485_4.RX_buf[start_addr_03 + 1];   
1102   3      
1103   3                      break; 
1104   3      
1105   3                  /*  40008   负载总功率设置              */
1106   3                  case 0x07:
1107   3                      sp350.fan_level = rs485_4.RX_buf[start_addr_03 + 1];   
1108   3      
1109   3                      break; 
1110   3      
1111   3                  /*  40009   报警温度设置               */
1112   3                  case 0x08:
1113   3                      sp350.fan_switch = rs485_4.RX_buf[start_addr_03 + 1];   
1114   3      
1115   3                      break; 
1116   3      
1117   3                  default:
1118   3                      break;
1119   3              }
1120   2              start_addr_03 += 2;
1121   2          }
1122   1      
1123   1          if( sp350.params_get_flag1 == 1 )
1124   1          {
1125   2              sp350.params_get_flag1 = 0;
1126   2              sp350_parms_init();
1127   2          }
1128   1          
1129   1      }
1130          
1131          /**
1132           * @brief 写单个输出寄存器-06
1133           *
1134           * @param   reg_addr：要写的寄存器地址
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 20  

1135           *          reg_val： 要写的值
1136           *
1137           * @return  void
1138           */
1139          void write_slave_06(uint16_t reg_addr, uint8_t reg_val_H, uint8_t reg_val_L)
1140          {
1141   1          uint8_t send_buf[8];
1142   1          uint16_t crc;
1143   1      
1144   1          delay_ms(10);
1145   1      
1146   1          send_buf[0] = SP350P_ADDR;       //Addr
1147   1          send_buf[1] = FUN_06;           //Fun
1148   1      
1149   1          /*   Value_H  && Value_L    */
1150   1          send_buf[2] = reg_addr >> 8;
1151   1          send_buf[3] = reg_addr;
1152   1          send_buf[4] = reg_val_H ;
1153   1          send_buf[5] = reg_val_L;
1154   1      
1155   1          /*   crc    */
1156   1          crc = MODBUS_CRC16(send_buf,6);
1157   1          send_buf[6] = crc >> 8;
1158   1          send_buf[7] = crc;
1159   1      
1160   1          memcpy(rs485_4.TX_buf,send_buf,8);
1161   1          /*   发送，后使能接收    */
1162   1          rs485_4.TX_send_bytelength = 8;
1163   1      
1164   1          TR4 = 1;
1165   1      
1166   1          delay_ms(2);
1167   1          SCON2T |= S4TI;                             //开始发送
1168   1          delay_ms(1);
1169   1      }
1170          
1171          
1172          /**
1173           * @brief 写单个输出寄存器-03
1174           *
1175           * @param   reg_addr：要写的寄存器地址
1176           *          reg_val： 要写的值
1177           *
1178           * @return  void
1179           */
1180          void get_slave_03_350p( void )
1181          {
1182   1          uint8_t send_buf[8];
1183   1          uint16_t crc;
1184   1      
1185   1          delay_ms(10);
1186   1      
1187   1          send_buf[0] = SP350P_ADDR;       //Addr
1188   1          send_buf[1] = FUN_03;           //Fun
1189   1      
1190   1          /*   Value_H  && Value_L    */
1191   1          send_buf[2] = 0x00;
1192   1          send_buf[3] = 0x00;
1193   1          send_buf[4] = 0x00 ;
1194   1          send_buf[5] = 0x09;
1195   1      
1196   1          /*   crc    */
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 21  

1197   1          crc = MODBUS_CRC16(send_buf,6);
1198   1          send_buf[6] = crc >> 8;
1199   1          send_buf[7] = crc;
1200   1      
1201   1          memcpy(rs485_4.TX_buf,send_buf,8);
1202   1          /*   发送，后使能接收    */
1203   1          rs485_4.TX_send_bytelength = 8;
1204   1      
1205   1          TR4 = 1;
1206   1      
1207   1          delay_ms(2);
1208   1          SCON2T |= S4TI;                             //开始发送
1209   1          delay_ms(1);
1210   1      }
1211          
1212          /**
1213           * @brief 写单个输出寄存器-03
1214           *
1215           * @param   reg_addr：要写的寄存器地址
1216           *          reg_val： 要写的值
1217           *
1218           * @return  void
1219           */
1220          void get_slave_03_MC01( void )
1221          {
1222   1          uint8_t send_buf[8];
1223   1          uint16_t crc;
1224   1      
1225   1          download_flag = 0;
1226   1          delay_ms(10);
1227   1      
1228   1          send_buf[0] = DFJ_ADDR;       //Addr
1229   1          send_buf[1] = FUN_03;           //Fun
1230   1      
1231   1          /*   Value_H  && Value_L    */
1232   1          send_buf[2] = 0x00;
1233   1          send_buf[3] = 0x00;
1234   1          send_buf[4] = 0x00 ;
1235   1          send_buf[5] = 0x0d;
1236   1      
1237   1          /*   crc    */
1238   1          crc = MODBUS_CRC16(send_buf,6);
1239   1          send_buf[6] = crc >> 8;
1240   1          send_buf[7] = crc;
1241   1      
1242   1          memcpy(rs485_2.send_buf,send_buf,8);
1243   1          /*   发送，后使能接收    */
1244   1          rs485_2.send_bytelength = 8;
1245   1      
1246   1          DR2_485 = 1;
1247   1      
1248   1          delay_ms(2);
1249   1          TI0 = 1;                            //开始发送
1250   1          delay_ms(1);
1251   1      }
1252          
1253          /**
1254           * @brief 写单个输出寄存器-03
1255           *
1256           * @param   reg_addr：要写的寄存器地址
1257           *          reg_val： 要写的值
1258           *
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 22  

1259           * @return  void
1260           */
1261          void get_slave_04_MC01( void )
1262          {
1263   1          uint8_t send_buf[8];
1264   1          uint16_t crc;
1265   1      
1266   1          download_flag = 0;
1267   1      
1268   1          send_buf[0] = DFJ_ADDR;     //Addr
1269   1          send_buf[1] = FUN_04;       //Fun
1270   1      
1271   1          /*   Value_H  && Value_L    */
1272   1          send_buf[2] = 0x00;
1273   1          send_buf[3] = 0x00;
1274   1          send_buf[4] = 0x00 ;
1275   1          send_buf[5] = 0x01;
1276   1      
1277   1          /*   crc    */
1278   1          crc = MODBUS_CRC16(send_buf,6);
1279   1          send_buf[6] = crc >> 8;
1280   1          send_buf[7] = crc;
1281   1      
1282   1          memcpy(rs485_2.send_buf,send_buf,8);
1283   1          /*   发送，后使能接收    */
1284   1          rs485_2.send_bytelength = 8;
1285   1      
1286   1          DR2_485 = 1;
1287   1      
1288   1          delay_ms(2);
1289   1          TI0 = 1;                            //开始发送
1290   1          delay_ms(1);
1291   1      }
1292          
1293          
1294          /**
1295           * @brief 写单个输出寄存器-06
1296           *
1297           * @param   reg_addr：要写的寄存器地址
1298           *          reg_val： 要写的值
1299           *
1300           * @return  void
1301           */
1302          void write_slave_06_MC01(uint16_t reg_addr, uint8_t reg_val_H, uint8_t reg_val_L)
1303          {
1304   1          uint8_t send_buf[8];
1305   1          uint16_t crc;
1306   1      
1307   1          delay_ms(10);
1308   1          download_flag = 0;
1309   1      
1310   1          send_buf[0] = DFJ_ADDR;       //Addr
1311   1          send_buf[1] = FUN_06;           //Fun
1312   1      
1313   1          /*   Value_H  && Value_L    */
1314   1          send_buf[2] = reg_addr >> 8;
1315   1          send_buf[3] = reg_addr;
1316   1          send_buf[4] = reg_val_H ;
1317   1          send_buf[5] = reg_val_L;
1318   1      
1319   1          /*   crc    */
1320   1          crc = MODBUS_CRC16(send_buf,6);
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 23  

1321   1          send_buf[6] = crc >> 8;
1322   1          send_buf[7] = crc;
1323   1      
1324   1          memcpy(rs485_2.send_buf,send_buf,8);
1325   1          /*   发送，后使能接收    */
1326   1          rs485_2.send_bytelength = 8;
1327   1      
1328   1          DR2_485 = 1;
1329   1          TI0 = 1;
1330   1          delay_ms(2);
1331   1      }
1332          
1333          /**
1334           * @brief 从机回复主机
1335           *  
1336           * @param   code_num:功能码       
1337           * @param   length:数据长度        
1338           * 
1339            @return  crc16:crc校验的值 2byte
1340           */
1341          void slave1_to_master(uint8_t code_num, uint8_t length)
1342          {
1343   1          uint16_t crc;
1344   1      
1345   1          switch(code_num)
1346   1          {
1347   2              case 0x03:
1348   2                  crc = MODBUS_CRC16(rs485_5.TX_buf,length);
1349   2      
1350   2                  // rs485_5.TX_buf[length+1] = crc;             //CRC H
1351   2                  // rs485_5.TX_buf[length] = crc>>8;            //CRC L
1352   2      
1353   2                  rs485_5.TX_buf[length] = crc;             //CRC H
1354   2                  rs485_5.TX_buf[length+1] = crc>>8;            //CRC L
1355   2                  
1356   2                  rs485_5.TX_send_bytelength = length + 2;
1357   2                  
1358   2                  break;
1359   2      
1360   2              case 0x04:
1361   2                  crc = MODBUS_CRC16(rs485_5.TX_buf,length);
1362   2      
1363   2                  rs485_5.TX_buf[length+1] = crc;              //CRC H
1364   2                  rs485_5.TX_buf[length] = crc>>8;             //CRC L
1365   2      
1366   2                  rs485_5.TX_send_bytelength = length + 2;
1367   2                  
1368   2                  break;    
1369   2      
1370   2              case 0x06:
1371   2                  memcpy(rs485_5.TX_buf,rs485_5.RX_buf,length);
1372   2                  rs485_5.TX_send_bytelength = length;
1373   2      
1374   2                  break;    
1375   2      
1376   2              case 0x10:
1377   2                  memcpy(rs485_5.TX_buf,rs485_5.RX_buf,6);
1378   2              
1379   2                  crc = MODBUS_CRC16(rs485_5.TX_buf,6);
1380   2      
1381   2                  rs485_5.TX_buf[6] = crc;                 //CRC H
1382   2                  rs485_5.TX_buf[7] = crc>>8;              //CRC L
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 24  

1383   2              
1384   2                  rs485_5.TX_send_bytelength = length;
1385   2                  
1386   2                  break; 
1387   2      
1388   2              default:
1389   2                  break;
1390   2          }
1391   1      
1392   1          TR5 = 1;                                //485可以发送
1393   1          delay_ms(2);
1394   1          SCON3T |= S5TI;                             //开始发送
1395   1          delay_ms(1);
1396   1      }
1397          
1398          /**
1399           * @brief crc校验函数
1400           * 
1401           * @param   buf：  Address(1 byte) +Funtion(1 byte) ）+Data(n byte)   
1402           * @param   length:数据长度           
1403           * 
1404            @return  crc16:crc校验的值 2byte
1405           */
1406          uint16_t MODBUS_CRC16(uint8_t *buf, uint16_t length)
1407          {
1408   1        uint8_t i;
1409   1        uint16_t  crc16;
1410   1      
1411   1          /* 1, 预置16位CRC寄存器为0xffff（即全为1）                          */
1412   1        crc16 = 0xffff; 
1413   1      
1414   1        do
1415   1        {
1416   2              /* 2, 把8位数据与16位CRC寄存器的低位相异或，把结果放于CRC寄存器     */        
1417   2          crc16 ^= (uint16_t)*buf;    //
1418   2          for(i=0; i<8; i++)    
1419   2          {
1420   3                  /* 3, 如果最低位为1，把CRC寄存器的内容右移一位(朝低位)，用0填补最高位 再异或0xA001    */
1421   3            if(crc16 & 1)
1422   3                  {
1423   4                      crc16 = (crc16 >> 1) ^ 0xA001;
1424   4                  }
1425   3                  /* 4, 如果最低位为0，把CRC寄存器的内容右移一位(朝低位)，用0填补最高位                */
1426   3                  else
1427   3                  {
1428   4                      crc16 >>= 1;
1429   4                  }   
1430   3          }
1431   2          buf++;
1432   2        }while(--length != 0);
1433   1      
1434   1        return  (crc16);
1435   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8311    ----
   CONSTANT SIZE    =     63    ----
   XDATA SIZE       =    197      64
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.60.7.0   MODBUS                                                            11/06/2025 19:53:04 PAGE 25  

   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
