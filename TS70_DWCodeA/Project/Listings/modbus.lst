C51 COMPILER V9.60.7.0   MODBUS                                                            10/10/2025 10:08:56 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MODBUS
OBJECT MODULE PLACED IN ..\Output\modbus.obj
COMPILER INVOKED BY: D:\APP\KEIL\MDK\C51\BIN\C51.EXE ..\Emembed\Src\modbus.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\BS
                    -P\Inc;..\Core\Inc;..\Driver;..\SYSTEM;..\Emembed\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\modbus.lst) TABS(2) OBJECT(..\
                    -Output\modbus.obj)

line level    source

   1          #include "modbus.h"
   2          
   3          MODBIS5_INFO modbus5;
   4          
   5          void Modbus_Event_Uart2( void )
   6          {
   7   1          uint16_t crc,rccrc = 0;
   8   1      
   9   1          /*1.接收完毕                                           */
  10   1          if( rs485_2.RX2_rev_end_Flag == 1 )
  11   1          {
  12   2              /*2.清空接收完毕标志位                              */    
  13   2              rs485_2.RX2_rev_end_Flag = 0;
  14   2      
  15   2              /*3.CRC校验                                         */
  16   2              crc = MODBUS_CRC16(rs485_2.RX2_buf, rs485_2.RX2_rev_cnt-2);
  17   2              rccrc = (rs485_2.RX2_buf[rs485_2.RX2_rev_cnt-1]) | (rs485_2.RX2_buf[rs485_2.RX2_rev_cnt-2]<<8);
  18   2      
  19   2              /*4.清空接收计数                                    */
  20   2              rs485_2.RX2_rev_cnt = 0; 
  21   2      
  22   2              /*5.CRC校验通过，进行地址域校验                      */
  23   2              if( crc == rccrc )
  24   2              {  
  25   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  26   3                  if( rs485_2.RX2_buf[0] == 0x01 )    
  27   3                  {
  28   4                      switch ( rs485_2.RX2_buf[1] )
  29   4                      {
  30   5                          case 0x06:
  31   5                              printf("uart2 is ok \r\n");
  32   5                              break;  
  33   5      
  34   5                          default:
  35   5                              break;
  36   5                      }
  37   4                  }
  38   3              }
  39   2          }
  40   1      }
  41          
  42          void Modbus_Event_Uart4( void )
  43          {
  44   1          uint16_t crc,rccrc = 0;
  45   1      
  46   1          /*1.接收完毕                                           */
  47   1          if( rs485_4.RX4_rev_end_Flag == 1 )
  48   1          {
  49   2              /*2.清空接收完毕标志位                              */    
  50   2              rs485_4.RX4_rev_end_Flag = 0;
  51   2      
  52   2              /*3.CRC校验                                         */
  53   2              crc = MODBUS_CRC16(rs485_4.RX4_buf, rs485_4.RX4_rev_cnt-2);
C51 COMPILER V9.60.7.0   MODBUS                                                            10/10/2025 10:08:56 PAGE 2   

  54   2              rccrc = (rs485_4.RX4_buf[rs485_4.RX4_rev_cnt-1]) | (rs485_4.RX4_buf[rs485_4.RX4_rev_cnt-2]<<8);
  55   2      
  56   2              /*4.清空接收计数                                    */
  57   2              rs485_4.RX4_rev_cnt = 0; 
  58   2      
  59   2              /*5.CRC校验通过，进行地址域校验                      */
  60   2              if( crc == rccrc )
  61   2              {
  62   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  63   3                  if( rs485_4.RX4_buf[0] == 0x01 )
  64   3                  {
  65   4                      switch ( rs485_4.RX4_buf[1] )
  66   4                      {
  67   5                          case 0x06:
  68   5      
  69   5                              break;  
  70   5      
  71   5                          default:
  72   5                              break;
  73   5                      }
  74   4                  }
  75   3              }
  76   2          }
  77   1      }
  78          
  79          void Modbus_Event_Uart5( void )
  80          {
  81   1          uint16_t crc,rccrc = 0;
  82   1      
  83   1          /*1.接收完毕                                           */
  84   1          if( rs485_5.RX_rcv_end_Flag == 1 )
  85   1          {
  86   2      
  87   2      
  88   2              /*3.CRC校验                                         */
  89   2              crc = MODBUS_CRC16(rs485_5.RX_buf, rs485_5.RX_rcv_cnt-2);
  90   2              rccrc = (rs485_5.RX_buf[rs485_5.RX_rcv_cnt - 2]) | (rs485_5.RX_buf[rs485_5.RX_rcv_cnt - 1] << 8);
  91   2      
  92   2      
  93   2              /*5.CRC校验通过，进行地址域校验                      */
  94   2              if( crc == rccrc )
  95   2              {
  96   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  97   3                  if( rs485_5.RX_buf[0] == 0x01 )
  98   3                  {
  99   4                      switch ( rs485_5.RX_buf[1] )
 100   4                      {    
 101   5                          case FUN_03:        Modbus_Fun03();         break; 
 102   5      
 103   5                          case FUN_06:        Modbus_Fun06();         break; 
 104   5                              
 105   5                          case FUN_16:        Modbus_Fun16();         break;  
 106   5      
 107   5                          default:                                    break;
 108   5                      }
 109   4                  }
 110   3              }
 111   2              /*4.清空接收计数                                    */
 112   2              rs485_5.RX_rcv_cnt = 0; 
 113   2              /*2.清空接收完毕标志位                              */    
 114   2              rs485_5.RX_rcv_end_Flag = 0;
 115   2          }
C51 COMPILER V9.60.7.0   MODBUS                                                            10/10/2025 10:08:56 PAGE 3   

 116   1      }
 117          
 118          void Modbus_Fun03( void )
 119          {
 120   1          uint16_t i;
 121   1      
 122   1          modbus5.send_val_addr  = 3;                //DATA1 H 位置
 123   1          modbus5.byte_cnt   = (rs485_5.RX_buf[4]<<8 | rs485_5.RX_buf[5]) *2;
 124   1          modbus5.start_addr = rs485_5.RX_buf[2]<<8 | rs485_5.RX_buf[3];
 125   1      
 126   1          rs485_5.TX_buf[0]  = HANSEN_ADDR;                //Addr
 127   1          rs485_5.TX_buf[1]  = FUN_03;                   //Fun
 128   1          rs485_5.TX_buf[2]  = modbus5.byte_cnt;       //Byte Count
 129   1      
 130   1          for( i = modbus5.start_addr; i < modbus5.start_addr + modbus5.byte_cnt/2; i++ )
 131   1          {
 132   2              /*    每次循环前初始化byte_info                       */
 133   2              modbus5.byte_info_H = modbus5.byte_info_L = 0X00;
 134   2              switch (i)
 135   2              {   
 136   3                  /*  x白边              */
 137   3                  case 0x00:  
 138   3                      modbus5.byte_info_H  = (uint8_t)hansen.addr_0x00 >> 8;
 139   3                      modbus5.byte_info_L  = (uint8_t)hansen.addr_0x00 & 0xFF; 
 140   3      
 141   3                      break;
 142   3                  /*  y白边              */
 143   3                  case 0x02:  
 144   3                      modbus5.byte_info_H  = (uint8_t)hansen.addr_0x02 >> 8;
 145   3                      modbus5.byte_info_L  = (uint8_t)hansen.addr_0x02 & 0xFF; 
 146   3      
 147   3                      break;
 148   3      
 149   3                  /*  获取当前主板语言              */
 150   3                  case 0x06:  
 151   3                      modbus5.byte_info_H  = (uint8_t)(hansen.addr_0x06 >> 8);
 152   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x06 & 0xFF); 
 153   3      
 154   3                      break;
 155   3      
 156   3                  /*  获取当前主板语言              */
 157   3                  case 0x10:  
 158   3                      modbus5.byte_info_H  = 0x00;
 159   3                      modbus5.byte_info_L  = 0x20; 
 160   3      
 161   3                      break;
 162   3      
 163   3                  /*  马达操作                      */
 164   3                  case 0x20:
 165   3                      modbus5.byte_info_H  = (uint8_t)hansen.addr_0x20 >> 8;
 166   3                      modbus5.byte_info_L  = (uint8_t)hansen.addr_0x20 & 0xFF; 
 167   3      
 168   3                      break;
 169   3      
 170   3                  /*  喷头操作                       */    
 171   3                  case 0x21:
 172   3                      modbus5.byte_info_H  = (uint8_t)hansen.addr_0x21 >> 8;
 173   3                      modbus5.byte_info_L  = (uint8_t)hansen.addr_0x21 & 0xFF;
 174   3      
 175   3                      break;
 176   3      
 177   3                  /*  喷头强度                  */
C51 COMPILER V9.60.7.0   MODBUS                                                            10/10/2025 10:08:56 PAGE 4   

 178   3                  case 0x22:    
 179   3                      modbus5.byte_info_H  = (uint8_t)hansen.addr_0x22 >> 8;
 180   3                      modbus5.byte_info_L  = (uint8_t)hansen.addr_0x22 & 0xFF; 
 181   3      
 182   3                      break;
 183   3      
 184   3                  /*  喷头数量                 */
 185   3                  case 0x23:   
 186   3                      modbus5.byte_info_H  = (uint8_t)hansen.addr_0x23 >> 8;
 187   3                      modbus5.byte_info_L  = (uint8_t)hansen.addr_0x23 & 0xFF; 
 188   3      
 189   3                      break;
 190   3      
 191   3                  /*  信号                 */
 192   3                  case 0x2d:    
 193   3                      modbus5.byte_info_H  = (uint8_t)hansen.addr_0x2d >> 8;
 194   3                      modbus5.byte_info_L  = (uint8_t)hansen.addr_0x2d & 0xFF; 
 195   3      
 196   3                      break;
 197   3      
 198   3                  /*  校准图类型                 */
 199   3                  case 0x30:   
 200   3                      modbus5.byte_info_H  = (uint8_t)hansen.addr_0x30 >> 8;
 201   3                      modbus5.byte_info_L  = (uint8_t)hansen.addr_0x30 & 0xFF; 
 202   3      
 203   3                      break; 
 204   3      
 205   3                  default:
 206   3                      break;
 207   3              }
 208   2              rs485_5.TX_buf[modbus5.send_val_addr++] = modbus5.byte_info_H;
 209   2              rs485_5.TX_buf[modbus5.send_val_addr++] = modbus5.byte_info_L;
 210   2          }
 211   1          slave_to_master(0x03,3 + modbus5.byte_cnt);
 212   1      }
 213          
 214          void Modbus_Fun06( void )
 215          {
 216   1          switch(rs485_5.RX_buf[3])
 217   1          {
 218   2              /*  马达操作                      */
 219   2              case 0x20:                         
 220   2                  hansen.addr_0x20 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 221   2      
 222   2                  break;  
 223   2      
 224   2              /*  喷头操作                       */    
 225   2              case 0x21:
 226   2                  hansen.addr_0x21 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 227   2      
 228   2                  break;
 229   2      
 230   2              /*  喷头强度                  */
 231   2              case 0x22:    
 232   2                  hansen.addr_0x22 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 233   2      
 234   2                  break;
 235   2      
 236   2              /*  喷头数量                 */
 237   2              case 0x23:   
 238   2                  hansen.addr_0x23 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 239   2      
C51 COMPILER V9.60.7.0   MODBUS                                                            10/10/2025 10:08:56 PAGE 5   

 240   2                  break;
 241   2      
 242   2              /*  信号                 */
 243   2              case 0x2d:    
 244   2                  hansen.addr_0x2d = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 245   2      
 246   2                  break;
 247   2      
 248   2              /*  校准图类型                 */
 249   2              case 0x30:   
 250   2                  hansen.addr_0x30 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 251   2      
 252   2                  break;
 253   2      
 254   2              // /*                    */
 255   2              // case 0x100:   
 256   2              //     //hansen.addr_0x2 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 257   2      
 258   2              //     break;
 259   2      
 260   2              // /*                    */
 261   2              // case 0x101:    
 262   2              //     //hansen.addr_0x24 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 263   2      
 264   2              //     break;
 265   2       
 266   2              // /*                    */
 267   2              // case 0x102:   
 268   2              //     //hansen.addr_0x25 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 269   2      
 270   2              //     break;
 271   2      
 272   2              default:
 273   2                  break;   
 274   2          }
 275   1      
 276   1          slave_to_master(FUN_06,8);
 277   1      
 278   1      }
 279          
 280          /**
 281           * @brief 写多个输出寄存器  16
 282           *
 283           * @param   void
 284           *
 285           * @return  void 
 286          **/
 287          void Modbus_Fun16( void )
 288          {
 289   1          uint16_t i;
 290   1      
 291   1          modbus5.rcv_value_addr = 7;                  //DATA1 H位置
 292   1          modbus5.byte_cnt   = rs485_5.RX_buf[6];
 293   1          modbus5.start_addr = rs485_5.RX_buf[2]<<8 | rs485_5.RX_buf[3];
 294   1      
 295   1          for( i = modbus5.start_addr; i < modbus5.start_addr + modbus5.byte_cnt/2; i++)
 296   1          {
 297   2              modbus5.byte_info_H = rs485_5.RX_buf[modbus5.rcv_value_addr];
 298   2              modbus5.byte_info_L = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 299   2              switch (i)
 300   2              {
 301   3                  /*  40001  24V LED开关状态设置                  */
C51 COMPILER V9.60.7.0   MODBUS                                                            10/10/2025 10:08:56 PAGE 6   

 302   3                  case 0:
 303   3      
 304   3      
 305   3                      break;
 306   3                  
 307   3                  /*  40002  两路PWM 开关状态及风速设置           */
 308   3                  case 1:
 309   3      
 310   3      
 311   3                      break;
 312   3      
 313   3                  /*  40003  220V 开关设置                        */
 314   3                  case 2:
 315   3      
 316   3                      break;
 317   3      
 318   3                  /*  40004  烘干功率及风扇档位 设置              */
 319   3                  case 3:
 320   3      
 321   3      
 322   3                      break;
 323   3      
 324   3                  /*  40005  NTC1 NTC2 alarm value 设置           */
 325   3                  case 4:
 326   3      
 327   3      
 328   3                      break;
 329   3                  
 330   3                  /*  40006  NTC3 alarm value 设置                */
 331   3                  case 5:
 332   3      
 333   3      
 334   3                      break;
 335   3      
 336   3                  /*  40007  同步开关设置                         */
 337   3                  case 6:
 338   3      
 339   3      
 340   3                      break;
 341   3      
 342   3                  default:
 343   3                      break;
 344   3              }
 345   2              modbus5.rcv_value_addr += 2;         //从Value1_H →→ 从Value2_H
 346   2          }
 347   1          
 348   1          slave_to_master(FUN_16,8);  
 349   1      
 350   1      }
 351          
 352          /**
 353           * @brief 写单个输出寄存器-06
 354           *
 355           * @param   reg_addr：要写的寄存器地址
 356           *          reg_val： 要写的值
 357           *
 358           * @return  void
 359           */
 360          void write_slave_06( uint8_t uart_num, uint16_t reg_addr, uint8_t reg_val_H, uint8_t reg_val_L)
 361          {
 362   1          uint8_t send_buf[8];
 363   1          uint16_t crc;
C51 COMPILER V9.60.7.0   MODBUS                                                            10/10/2025 10:08:56 PAGE 7   

 364   1      
 365   1          delay_ms(10);
 366   1          download_flag = 0;
 367   1      
 368   1          send_buf[0] = SLAVE_ADDR;       //Addr
 369   1          send_buf[1] = FUN_06;           //Fun
 370   1      
 371   1          /*   Value_H  && Value_L    */
 372   1          send_buf[2] = reg_addr >> 8;
 373   1          send_buf[3] = reg_addr;
 374   1          send_buf[4] = reg_val_H ;
 375   1          send_buf[5] = reg_val_L;
 376   1      
 377   1          /*   crc    */
 378   1          crc = MODBUS_CRC16(send_buf,6);
 379   1          send_buf[6] = crc >> 8;
 380   1          send_buf[7] = crc;
 381   1      
 382   1          memcpy(rs485_5.TX_buf,send_buf,8);
 383   1          /*   发送，后使能接收    */
 384   1          rs485_5.TX_send_bytelength = 8;
 385   1      
 386   1          TR5 = 1;
 387   1      
 388   1          delay_ms(2);
 389   1          SCON3T |= S5TI;                             //开始发送
 390   1          delay_ms(1);
 391   1      }
*** WARNING C280 IN LINE 360 OF ..\Emembed\Src\modbus.c: 'uart_num': unreferenced local variable
 392          
 393          
 394          /**
 395           * @brief 从机回复主机
 396           *  
 397           * @param   code_num:功能码       
 398           * @param   length:数据长度        
 399           * 
 400            @return  crc16:crc校验的值 2byte
 401           */
 402          void slave_to_master(uint8_t code_num, uint8_t length)
 403          {
 404   1          uint16_t crc;
 405   1      
 406   1          switch(code_num)
 407   1          {
 408   2              case 0x03:
 409   2                  crc = MODBUS_CRC16(rs485_5.TX_buf,length);
 410   2      
 411   2                  // rs485_5.TX_buf[length+1] = crc;             //CRC H
 412   2                  // rs485_5.TX_buf[length] = crc>>8;            //CRC L
 413   2      
 414   2                  rs485_5.TX_buf[length] = crc;             //CRC H
 415   2                  rs485_5.TX_buf[length+1] = crc>>8;            //CRC L
 416   2                  
 417   2                  rs485_5.TX_send_bytelength = length + 2;
 418   2                  
 419   2                  break;
 420   2      
 421   2              case 0x04:
 422   2                  crc = MODBUS_CRC16(rs485_5.TX_buf,length);
 423   2      
 424   2                  rs485_5.TX_buf[length+1] = crc;              //CRC H
C51 COMPILER V9.60.7.0   MODBUS                                                            10/10/2025 10:08:56 PAGE 8   

 425   2                  rs485_5.TX_buf[length] = crc>>8;             //CRC L
 426   2      
 427   2                  rs485_5.TX_send_bytelength = length + 2;
 428   2                  
 429   2                  break;    
 430   2      
 431   2              case 0x06:
 432   2                  memcpy(rs485_5.TX_buf,rs485_5.RX_buf,length);
 433   2                  rs485_5.RX_buf[1] = 0;
 434   2                  rs485_5.TX_send_bytelength = length;
 435   2                  printf("==here==\r\n");
 436   2                  break;    
 437   2      
 438   2              case 0x10:
 439   2                  memcpy(rs485_5.TX_buf,rs485_5.RX_buf,6);
 440   2              
 441   2                  crc = MODBUS_CRC16(rs485_5.TX_buf,6);
 442   2      
 443   2                  rs485_5.TX_buf[7] = crc;                 //CRC H
 444   2                  rs485_5.TX_buf[6] = crc>>8;              //CRC L
 445   2              
 446   2                  rs485_5.TX_send_bytelength = length;
 447   2                  
 448   2                  break; 
 449   2      
 450   2              default:
 451   2                  break;
 452   2          }
 453   1      
 454   1          TR5 = 1;                                //485可以发送
 455   1          delay_ms(2);
 456   1          SCON3T |= S5TI;                             //开始发送
 457   1          delay_ms(1);
 458   1      }
 459          
 460          /**
 461           * @brief crc校验函数
 462           * 
 463           * @param   buf：  Address(1 byte) +Funtion(1 byte) ）+Data(n byte)   
 464           * @param   length:数据长度           
 465           * 
 466            @return  crc16:crc校验的值 2byte
 467           */
 468          uint16_t MODBUS_CRC16(uint8_t *buf, uint8_t length)
 469          {
 470   1        uint8_t i;
 471   1        uint16_t  crc16;
 472   1      
 473   1          /* 1, 预置16位CRC寄存器为0xffff（即全为1）                          */
 474   1        crc16 = 0xffff; 
 475   1      
 476   1        do
 477   1        {
 478   2              /* 2, 把8位数据与16位CRC寄存器的低位相异或，把结果放于CRC寄存器     */    
             -    
 479   2          crc16 ^= (uint16_t)*buf;    //
 480   2          for(i=0; i<8; i++)    
 481   2          {
 482   3                  /* 3, 如果最低位为1，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位 再异或0xA001    */
 483   3            if(crc16 & 1)
 484   3                  {
C51 COMPILER V9.60.7.0   MODBUS                                                            10/10/2025 10:08:56 PAGE 9   

 485   4                      crc16 = (crc16 >> 1) ^ 0xA001;
 486   4                  }
 487   3                  /* 4, 如果最低位为0，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位                */
 488   3                  else
 489   3                  {
 490   4                      crc16 >>= 1;
 491   4                  }   
 492   3          }
 493   2          buf++;
 494   2        }while(--length != 0);
 495   1      
 496   1        return  (crc16);
 497   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1340    ----
   CONSTANT SIZE    =     26    ----
   XDATA SIZE       =      7      21
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
