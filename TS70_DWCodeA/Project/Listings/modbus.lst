C51 COMPILER V9.60.7.0   MODBUS                                                            10/09/2025 15:07:43 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MODBUS
OBJECT MODULE PLACED IN ..\Output\modbus.obj
COMPILER INVOKED BY: D:\APP\KEIL\MDK\C51\BIN\C51.EXE ..\Emembed\Src\modbus.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\BS
                    -P\Inc;..\Core\Inc;..\Driver;..\SYSTEM;..\Emembed\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\modbus.lst) TABS(2) OBJECT(..\
                    -Output\modbus.obj)

line level    source

   1          #include "modbus.h"
   2          
   3          MODBIS5_INFO modbus5;
   4          
   5          void Modbus_Event_Uart2( void )
   6          {
   7   1          uint16_t crc,rccrc = 0;
   8   1      
   9   1          /*1.接收完毕                                           */
  10   1          if( rs485_2.RX2_rev_end_Flag == 1 )
  11   1          {
  12   2              /*2.清空接收完毕标志位                              */    
  13   2              rs485_2.RX2_rev_end_Flag = 0;
  14   2      
  15   2              /*3.CRC校验                                         */
  16   2              crc = MODBUS_CRC16(rs485_2.RX2_buf, rs485_2.RX2_rev_cnt-2);
  17   2              rccrc = (rs485_2.RX2_buf[rs485_2.RX2_rev_cnt-1]) | (rs485_2.RX2_buf[rs485_2.RX2_rev_cnt-2]<<8);
  18   2      
  19   2              /*4.清空接收计数                                    */
  20   2              rs485_2.RX2_rev_cnt = 0; 
  21   2      
  22   2              /*5.CRC校验通过，进行地址域校验                      */
  23   2              if( crc == rccrc )
  24   2              {  
  25   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  26   3                  if( rs485_2.RX2_buf[0] == 0x01 )    
  27   3                  {
  28   4                      switch ( rs485_2.RX2_buf[1] )
  29   4                      {
  30   5                          case 0x06:
  31   5                              printf("uart2 is ok \r\n");
  32   5                              break;  
  33   5      
  34   5                          default:
  35   5                              break;
  36   5                      }
  37   4                  }
  38   3              }
  39   2          }
  40   1      }
  41          
  42          void Modbus_Event_Uart4( void )
  43          {
  44   1          uint16_t crc,rccrc = 0;
  45   1      
  46   1          /*1.接收完毕                                           */
  47   1          if( rs485_4.RX4_rev_end_Flag == 1 )
  48   1          {
  49   2              /*2.清空接收完毕标志位                              */    
  50   2              rs485_4.RX4_rev_end_Flag = 0;
  51   2      
  52   2              /*3.CRC校验                                         */
  53   2              crc = MODBUS_CRC16(rs485_4.RX4_buf, rs485_4.RX4_rev_cnt-2);
C51 COMPILER V9.60.7.0   MODBUS                                                            10/09/2025 15:07:43 PAGE 2   

  54   2              rccrc = (rs485_4.RX4_buf[rs485_4.RX4_rev_cnt-1]) | (rs485_4.RX4_buf[rs485_4.RX4_rev_cnt-2]<<8);
  55   2      
  56   2              /*4.清空接收计数                                    */
  57   2              rs485_4.RX4_rev_cnt = 0; 
  58   2      
  59   2              /*5.CRC校验通过，进行地址域校验                      */
  60   2              if( crc == rccrc )
  61   2              {
  62   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  63   3                  if( rs485_4.RX4_buf[0] == 0x01 )
  64   3                  {
  65   4                      switch ( rs485_4.RX4_buf[1] )
  66   4                      {
  67   5                          case 0x06:
  68   5      
  69   5                              break;  
  70   5      
  71   5                          default:
  72   5                              break;
  73   5                      }
  74   4                  }
  75   3              }
  76   2          }
  77   1      }
  78          
  79          void Modbus_Event_Uart5( void )
  80          {
  81   1          uint16_t crc,rccrc = 0;
  82   1      
  83   1          /*1.接收完毕                                           */
  84   1          if( rs485_5.RX_rcv_end_Flag == 1 )
  85   1          {
  86   2              /*2.清空接收完毕标志位                              */    
  87   2              rs485_5.RX_rcv_end_Flag = 0;
  88   2      
  89   2              /*3.CRC校验                                         */
  90   2              crc = MODBUS_CRC16(rs485_5.RX_buf, rs485_5.RX_rcv_cnt-2);
  91   2              rccrc = (rs485_5.RX_buf[rs485_5.RX_rcv_cnt - 2]) | (rs485_5.RX_buf[rs485_5.RX_rcv_cnt - 1] << 8);
  92   2      
  93   2              /*4.清空接收计数                                    */
  94   2              rs485_5.RX_rcv_cnt = 0; 
  95   2      
  96   2              /*5.CRC校验通过，进行地址域校验                      */
  97   2              if( crc == rccrc )
  98   2              {
  99   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
 100   3                  if( rs485_5.RX_buf[0] == 0x01 )
 101   3                  {
 102   4                      switch ( rs485_5.RX_buf[1] )
 103   4                      {    
 104   5                          case FUN_03:        Modbus_Fun03();         break; 
 105   5      
 106   5                          case FUN_06:        Modbus_Fun06();         break; 
 107   5                              
 108   5                          case FUN_16:        Modbus_Fun16();         break;  
 109   5      
 110   5                          default:                                    break;
 111   5                      }
 112   4                  }
 113   3              }
 114   2          }
 115   1      }
C51 COMPILER V9.60.7.0   MODBUS                                                            10/09/2025 15:07:43 PAGE 3   

 116          
 117          void Modbus_Fun03( void )
 118          {
 119   1          uint16_t i;
 120   1      
 121   1          modbus5.send_val_addr  = 3;                //DATA1 H 位置
 122   1          modbus5.byte_cnt   = (rs485_5.RX_buf[4]<<8 | rs485_5.RX_buf[5]) *2;
 123   1          modbus5.start_addr = rs485_5.RX_buf[2]<<8 | rs485_5.RX_buf[3];
 124   1      
 125   1          rs485_5.TX_buf[0]  = HANSEN_ADDR;                //Addr
 126   1          rs485_5.TX_buf[1]  = FUN_03;                   //Fun
 127   1          rs485_5.TX_buf[2]  = modbus5.byte_cnt;       //Byte Count
 128   1      
 129   1          for( i = modbus5.start_addr; i < modbus5.start_addr + modbus5.byte_cnt/2; i++ )
 130   1          {
 131   2              /*    每次循环前初始化byte_info                       */
 132   2              modbus5.byte_info_H = modbus5.byte_info_L = 0X00;
 133   2              switch (i)
 134   2              {   
 135   3                  /*  x白边              */
 136   3                  case 0x00:  
 137   3                      modbus5.byte_info_H  = (uint8_t)hansen.addr_0x00 >> 8;
 138   3                      modbus5.byte_info_L  = (uint8_t)hansen.addr_0x00 & 0xFF; 
 139   3      
 140   3                      break;
 141   3                  /*  y白边              */
 142   3                  case 0x02:  
 143   3                      modbus5.byte_info_H  = (uint8_t)hansen.addr_0x02 >> 8;
 144   3                      modbus5.byte_info_L  = (uint8_t)hansen.addr_0x02 & 0xFF; 
 145   3      
 146   3                      break;
 147   3      
 148   3                  /*  获取当前主板语言              */
 149   3                  case 0x06:  
 150   3                      modbus5.byte_info_H  = (uint8_t)(hansen.addr_0x06 >> 8);
 151   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x06 & 0xFF); 
 152   3      
 153   3                      break;
 154   3      
 155   3                  /*  获取当前主板语言              */
 156   3                  case 0x10:  
 157   3                      modbus5.byte_info_H  = 0x00;
 158   3                      modbus5.byte_info_L  = 0x20; 
 159   3      
 160   3                      break;
 161   3      
 162   3                  /*  马达操作                      */
 163   3                  case 0x20:
 164   3                      modbus5.byte_info_H  = (uint8_t)hansen.addr_0x20 >> 8;
 165   3                      modbus5.byte_info_L  = (uint8_t)hansen.addr_0x20 & 0xFF; 
 166   3      
 167   3                      break;
 168   3      
 169   3                  /*  喷头操作                       */    
 170   3                  case 0x21:
 171   3                      modbus5.byte_info_H  = (uint8_t)hansen.addr_0x21 >> 8;
 172   3                      modbus5.byte_info_L  = (uint8_t)hansen.addr_0x21 & 0xFF;
 173   3      
 174   3                      break;
 175   3      
 176   3                  /*  喷头强度                  */
 177   3                  case 0x22:    
C51 COMPILER V9.60.7.0   MODBUS                                                            10/09/2025 15:07:43 PAGE 4   

 178   3                      modbus5.byte_info_H  = (uint8_t)hansen.addr_0x22 >> 8;
 179   3                      modbus5.byte_info_L  = (uint8_t)hansen.addr_0x22 & 0xFF; 
 180   3      
 181   3                      break;
 182   3      
 183   3                  /*  喷头数量                 */
 184   3                  case 0x23:   
 185   3                      modbus5.byte_info_H  = (uint8_t)hansen.addr_0x23 >> 8;
 186   3                      modbus5.byte_info_L  = (uint8_t)hansen.addr_0x23 & 0xFF; 
 187   3      
 188   3                      break;
 189   3      
 190   3                  /*  信号                 */
 191   3                  case 0x2d:    
 192   3                      modbus5.byte_info_H  = (uint8_t)hansen.addr_0x2d >> 8;
 193   3                      modbus5.byte_info_L  = (uint8_t)hansen.addr_0x2d & 0xFF; 
 194   3      
 195   3                      break;
 196   3      
 197   3                  /*  校准图类型                 */
 198   3                  case 0x30:   
 199   3                      modbus5.byte_info_H  = (uint8_t)hansen.addr_0x30 >> 8;
 200   3                      modbus5.byte_info_L  = (uint8_t)hansen.addr_0x30 & 0xFF; 
 201   3      
 202   3                      break; 
 203   3      
 204   3                  default:
 205   3                      break;
 206   3              }
 207   2              rs485_5.TX_buf[modbus5.send_val_addr++] = modbus5.byte_info_H;
 208   2              rs485_5.TX_buf[modbus5.send_val_addr++] = modbus5.byte_info_L;
 209   2          }
 210   1          slave_to_master(0x03,3 + modbus5.byte_cnt);
 211   1      }
 212          
 213          void Modbus_Fun06( void )
 214          {
 215   1          switch(rs485_5.RX_buf[3])
 216   1          {
 217   2              /*  马达操作                      */
 218   2              case 0x20:                         
 219   2                  hansen.addr_0x20 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 220   2      
 221   2                  break;  
 222   2      
 223   2              /*  喷头操作                       */    
 224   2              case 0x21:
 225   2                  hansen.addr_0x21 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 226   2      
 227   2                  break;
 228   2      
 229   2              /*  喷头强度                  */
 230   2              case 0x22:    
 231   2                  hansen.addr_0x22 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 232   2      
 233   2                  break;
 234   2      
 235   2              /*  喷头数量                 */
 236   2              case 0x23:   
 237   2                  hansen.addr_0x23 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 238   2      
 239   2                  break;
C51 COMPILER V9.60.7.0   MODBUS                                                            10/09/2025 15:07:43 PAGE 5   

 240   2      
 241   2              /*  信号                 */
 242   2              case 0x2d:    
 243   2                  hansen.addr_0x2d = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 244   2      
 245   2                  break;
 246   2      
 247   2              /*  校准图类型                 */
 248   2              case 0x30:   
 249   2                  hansen.addr_0x30 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 250   2      
 251   2                  break;
 252   2      
 253   2              // /*                    */
 254   2              // case 0x100:   
 255   2              //     //hansen.addr_0x2 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 256   2      
 257   2              //     break;
 258   2      
 259   2              // /*                    */
 260   2              // case 0x101:    
 261   2              //     //hansen.addr_0x24 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 262   2      
 263   2              //     break;
 264   2       
 265   2              // /*                    */
 266   2              // case 0x102:   
 267   2              //     //hansen.addr_0x25 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 268   2      
 269   2              //     break;
 270   2      
 271   2              default:
 272   2                  break;   
 273   2          }
 274   1      
 275   1          slave_to_master(0x06,8);
 276   1      
 277   1      }
 278          
 279          /**
 280           * @brief 写多个输出寄存器  16
 281           *
 282           * @param   void
 283           *
 284           * @return  void 
 285          **/
 286          void Modbus_Fun16( void )
 287          {
 288   1          uint16_t i;
 289   1      
 290   1          modbus5.rcv_value_addr = 7;                  //DATA1 H位置
 291   1          modbus5.byte_cnt   = rs485_5.RX_buf[6];
 292   1          modbus5.start_addr = rs485_5.RX_buf[2]<<8 | rs485_5.RX_buf[3];
 293   1      
 294   1          for( i = modbus5.start_addr; i < modbus5.start_addr + modbus5.byte_cnt/2; i++)
 295   1          {
 296   2              modbus5.byte_info_H = rs485_5.RX_buf[modbus5.rcv_value_addr];
 297   2              modbus5.byte_info_L = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 298   2              switch (i)
 299   2              {
 300   3                  /*  40001  24V LED开关状态设置                  */
 301   3                  case 0:
C51 COMPILER V9.60.7.0   MODBUS                                                            10/09/2025 15:07:43 PAGE 6   

 302   3      
 303   3      
 304   3                      break;
 305   3                  
 306   3                  /*  40002  两路PWM 开关状态及风速设置           */
 307   3                  case 1:
 308   3      
 309   3      
 310   3                      break;
 311   3      
 312   3                  /*  40003  220V 开关设置                        */
 313   3                  case 2:
 314   3      
 315   3                      break;
 316   3      
 317   3                  /*  40004  烘干功率及风扇档位 设置              */
 318   3                  case 3:
 319   3      
 320   3      
 321   3                      break;
 322   3      
 323   3                  /*  40005  NTC1 NTC2 alarm value 设置           */
 324   3                  case 4:
 325   3      
 326   3      
 327   3                      break;
 328   3                  
 329   3                  /*  40006  NTC3 alarm value 设置                */
 330   3                  case 5:
 331   3      
 332   3      
 333   3                      break;
 334   3      
 335   3                  /*  40007  同步开关设置                         */
 336   3                  case 6:
 337   3      
 338   3      
 339   3                      break;
 340   3      
 341   3                  default:
 342   3                      break;
 343   3              }
 344   2              modbus5.rcv_value_addr += 2;         //从Value1_H →→ 从Value2_H
 345   2          }
 346   1          
 347   1          slave_to_master(0x10,8);  
 348   1      
 349   1      }
 350          
 351          /**
 352           * @brief 写单个输出寄存器-06
 353           *
 354           * @param   reg_addr：要写的寄存器地址
 355           *          reg_val： 要写的值
 356           *
 357           * @return  void
 358           */
 359          void write_slave_06( uint8_t uart_num, uint16_t reg_addr, uint8_t reg_val_H, uint8_t reg_val_L)
 360          {
 361   1          uint8_t send_buf[8];
 362   1          uint16_t crc;
 363   1      
C51 COMPILER V9.60.7.0   MODBUS                                                            10/09/2025 15:07:43 PAGE 7   

 364   1          delay_ms(10);
 365   1          download_flag = 0;
 366   1      
 367   1          send_buf[0] = SLAVE_ADDR;       //Addr
 368   1          send_buf[1] = FUN_06;           //Fun
 369   1      
 370   1          /*   Value_H  && Value_L    */
 371   1          send_buf[2] = reg_addr >> 8;
 372   1          send_buf[3] = reg_addr;
 373   1          send_buf[4] = reg_val_H ;
 374   1          send_buf[5] = reg_val_L;
 375   1      
 376   1          /*   crc    */
 377   1          crc = MODBUS_CRC16(send_buf,6);
 378   1          send_buf[6] = crc >> 8;
 379   1          send_buf[7] = crc;
 380   1      
 381   1          memcpy(rs485_5.TX_buf,send_buf,8);
 382   1          /*   发送，后使能接收    */
 383   1          rs485_5.TX_send_bytelength = 8;
 384   1      
 385   1          TR5 = 1;
 386   1      
 387   1          delay_ms(2);
 388   1          SCON3T |= S5TI;                             //开始发送
 389   1          delay_ms(1);
 390   1      }
*** WARNING C280 IN LINE 359 OF ..\Emembed\Src\modbus.c: 'uart_num': unreferenced local variable
 391          
 392          
 393          /**
 394           * @brief 从机回复主机
 395           *  
 396           * @param   code_num:功能码       
 397           * @param   length:数据长度        
 398           * 
 399            @return  crc16:crc校验的值 2byte
 400           */
 401          void slave_to_master(uint8_t code_num,uint8_t length)
 402          {
 403   1          uint16_t crc;
 404   1      
 405   1          switch (code_num)
 406   1          {
 407   2              case 0x03:
 408   2                  crc = MODBUS_CRC16(rs485_5.TX_buf,length);
 409   2      
 410   2                  // rs485_5.TX_buf[length+1] = crc;             //CRC H
 411   2                  // rs485_5.TX_buf[length] = crc>>8;            //CRC L
 412   2      
 413   2                  rs485_5.TX_buf[length] = crc;             //CRC H
 414   2                  rs485_5.TX_buf[length+1] = crc>>8;            //CRC L
 415   2                  
 416   2                  rs485_5.TX_send_bytelength = length + 2;
 417   2                  
 418   2                  break;
 419   2      
 420   2              case 0x04:
 421   2                  crc = MODBUS_CRC16(rs485_5.TX_buf,length);
 422   2      
 423   2                  rs485_5.TX_buf[length+1] = crc;              //CRC H
 424   2                  rs485_5.TX_buf[length] = crc>>8;             //CRC L
C51 COMPILER V9.60.7.0   MODBUS                                                            10/09/2025 15:07:43 PAGE 8   

 425   2      
 426   2                  rs485_5.TX_send_bytelength = length + 2;
 427   2                  
 428   2                  break;    
 429   2      
 430   2              case 0x06:
 431   2                  // memcpy(rs485_5.TX_buf,rs485_5.RX_buf,8);
 432   2                  rs485_5.TX_buf[0] = 1;
 433   2                  rs485_5.TX_buf[1] = 1;
 434   2                  rs485_5.TX_buf[2] = 1;
 435   2                  rs485_5.TX_buf[3] = 1;
 436   2                  rs485_5.TX_buf[4] = 1;
 437   2                  rs485_5.TX_buf[5] = 1;
 438   2                  rs485_5.TX_buf[6] = 1;
 439   2                  rs485_5.TX_buf[7] = 1;
 440   2                  rs485_5.TX_send_bytelength = length;
 441   2                  
 442   2                  break;    
 443   2      
 444   2              case 0x10:
 445   2                  memcpy(rs485_5.TX_buf,rs485_5.RX_buf,6);
 446   2              
 447   2                  crc = MODBUS_CRC16(rs485_5.TX_buf,6);
 448   2      
 449   2                  rs485_5.TX_buf[7] = crc;                 //CRC H
 450   2                  rs485_5.TX_buf[6] = crc>>8;              //CRC L
 451   2              
 452   2                  rs485_5.TX_send_bytelength = length;
 453   2                  
 454   2                  break; 
 455   2      
 456   2              default:
 457   2                  break;
 458   2          }
 459   1      
 460   1          TR5 = 1;                                //485可以发送
 461   1          delay_ms(2);
 462   1          SCON3T |= S5TI;                             //开始发送
 463   1          delay_ms(1);
 464   1      }
 465          
 466          /**
 467           * @brief crc校验函数
 468           * 
 469           * @param   buf：  Address(1 byte) +Funtion(1 byte) ）+Data(n byte)   
 470           * @param   length:数据长度           
 471           * 
 472            @return  crc16:crc校验的值 2byte
 473           */
 474          uint16_t MODBUS_CRC16(uint8_t *buf, uint8_t length)
 475          {
 476   1        uint8_t i;
 477   1        uint16_t  crc16;
 478   1      
 479   1          /* 1, 预置16位CRC寄存器为0xffff（即全为1）                          */
 480   1        crc16 = 0xffff; 
 481   1      
 482   1        do
 483   1        {
 484   2              /* 2, 把8位数据与16位CRC寄存器的低位相异或，把结果放于CRC寄存器     */    
             -    
 485   2          crc16 ^= (uint16_t)*buf;    //
C51 COMPILER V9.60.7.0   MODBUS                                                            10/09/2025 15:07:43 PAGE 9   

 486   2          for(i=0; i<8; i++)    
 487   2          {
 488   3                  /* 3, 如果最低位为1，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位 再异或0xA001    */
 489   3            if(crc16 & 1)
 490   3                  {
 491   4                      crc16 = (crc16 >> 1) ^ 0xA001;
 492   4                  }
 493   3                  /* 4, 如果最低位为0，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位                */
 494   3                  else
 495   3                  {
 496   4                      crc16 >>= 1;
 497   4                  }   
 498   3          }
 499   2          buf++;
 500   2        }while(--length != 0);
 501   1      
 502   1        return  (crc16);
 503   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1314    ----
   CONSTANT SIZE    =     15    ----
   XDATA SIZE       =      7      21
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
