C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MODBUS
OBJECT MODULE PLACED IN ..\Output\modbus.obj
COMPILER INVOKED BY: D:\APP\KEIL\MDK\C51\BIN\C51.EXE ..\Emembed\Src\modbus.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\BS
                    -P\Inc;..\Core\Inc;..\Driver;..\SYSTEM;..\Emembed\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\modbus.lst) TABS(2) OBJECT(..\
                    -Output\modbus.obj)

line level    source

   1          #include "modbus.h"
   2          
   3          MODBIS5_INFO modbus5;
   4          MODBIS4_INFO modbus4;
   5          
   6          uint8_t fuyin_flag = 0;
   7          
   8          void Modbus_Event_Uart2( void )
   9          {
  10   1          uint16_t crc,rccrc = 0;
  11   1      
  12   1          /*1.接收完毕                                           */
  13   1          if( rs485_2.RX2_rev_end_Flag == 1 )
  14   1          {
  15   2              /*2.清空接收完毕标志位                              */    
  16   2              rs485_2.RX2_rev_end_Flag = 0;
  17   2      
  18   2              /*3.CRC校验                                         */
  19   2              crc = MODBUS_CRC16(rs485_2.RX2_buf, rs485_2.RX2_rev_cnt-2);
  20   2              rccrc = (rs485_2.RX2_buf[rs485_2.RX2_rev_cnt-1]) | (rs485_2.RX2_buf[rs485_2.RX2_rev_cnt-2]<<8);
  21   2      
  22   2              /*4.清空接收计数                                    */
  23   2              rs485_2.RX2_rev_cnt = 0; 
  24   2      
  25   2              /*5.CRC校验通过，进行地址域校验                      */
  26   2              if( crc == rccrc )
  27   2              {  
  28   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  29   3                  if( rs485_2.RX2_buf[0] == 0x01 )    
  30   3                  {
  31   4                      switch ( rs485_2.RX2_buf[1] )
  32   4                      {
  33   5                          case 0x06:
  34   5                              // printf("uart2 is ok \r\n");
  35   5                              break;  
  36   5      
  37   5                          default:
  38   5                              break;
  39   5                      }
  40   4                  }
  41   3              }
  42   2          }
  43   1      }
  44          
  45          void Modbus_Event_Uart4( void )
  46          {
  47   1          uint16_t crc,rccrc = 0;
  48   1      
  49   1          /*1.接收完毕                                           */
  50   1          if( rs485_4.RX_rcv_end_Flag == 1 )
  51   1          {
  52   2              /*2.清空接收完毕标志位                              */    
  53   2              rs485_4.RX_rcv_end_Flag = 0;
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 2   

  54   2      
  55   2              /*3.CRC校验                                         */
  56   2              crc = MODBUS_CRC16(rs485_4.RX_buf, rs485_4.RX_rcv_cnt-2);
  57   2              rccrc = (rs485_4.RX_buf[rs485_4.RX_rcv_cnt-1]) | (rs485_4.RX_buf[rs485_4.RX_rcv_cnt-2]<<8);
  58   2      
  59   2              /*4.清空接收计数                                    */
  60   2              rs485_4.RX_rcv_cnt = 0; 
  61   2      
  62   2              /*5.CRC校验通过，进行地址域校验                      */
  63   2              if( crc == rccrc )
  64   2              {
  65   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  66   3                  if( rs485_4.RX_buf[0] == SP350P_ADDR )
  67   3                  {
  68   4                      switch ( rs485_4.RX_buf[1] )
  69   4                      {
  70   5                          case FUN_03:        Modbus_Fun03_slave2();         break; 
  71   5      
  72   5                              break;  
  73   5      
  74   5                          default:
  75   5                              break;
  76   5                      }
  77   4                  }
  78   3              }
  79   2          }
  80   1      }
  81          
  82          void Modbus_Event_Uart5( void )
  83          {
  84   1          uint16_t crc,rccrc = 0;
  85   1      
  86   1          /*1.接收完毕                                           */
  87   1          if( rs485_5.RX_rcv_end_Flag == 1 )
  88   1          {
  89   2              /*2.CRC校验                                         */
  90   2              crc = MODBUS_CRC16(rs485_5.RX_buf, rs485_5.RX_rcv_cnt-2);
  91   2              rccrc = (rs485_5.RX_buf[rs485_5.RX_rcv_cnt - 2]) | (rs485_5.RX_buf[rs485_5.RX_rcv_cnt - 1] << 8);
  92   2      
  93   2              /*3.CRC校验通过，进行地址域校验                      */
  94   2              if( crc == rccrc )
  95   2              {
  96   3                  /*4.地址域校验通过，进入相应功能函数进行处理      */
  97   3                  if( rs485_5.RX_buf[0] == HANSEN_ADDR )
  98   3                  {
  99   4                      switch ( rs485_5.RX_buf[1] )
 100   4                      {    
 101   5                          case FUN_03:        Modbus_Fun03_slave1();         break; 
 102   5      
 103   5                          case FUN_06:        Modbus_Fun06_slave1();         break; 
 104   5                              
 105   5                          case FUN_16:        Modbus_Fun16_slave1();         break;  
 106   5      
 107   5                          default:                                    break;
 108   5                      }
 109   4                  }
 110   3              }
 111   2              /*5.清空接收计数                                    */
 112   2              rs485_5.RX_rcv_cnt = 0; 
 113   2              /*6.清空接收完毕标志位                              */    
 114   2              rs485_5.RX_rcv_end_Flag = 0;
 115   2          }
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 3   

 116   1      }
 117          
 118          void Modbus_Fun03_slave1( void )
 119          {
 120   1          uint16_t i;
 121   1      
 122   1          modbus5.send_val_addr  = 3;                //DATA1 H 位置
 123   1          modbus5.byte_cnt   = (rs485_5.RX_buf[4]<<8 | rs485_5.RX_buf[5]) *2;
 124   1          modbus5.start_addr = rs485_5.RX_buf[2]<<8 | rs485_5.RX_buf[3];
 125   1      
 126   1          rs485_5.TX_buf[0]  = HANSEN_ADDR;                //Addr
 127   1          rs485_5.TX_buf[1]  = FUN_03;                   //Fun
 128   1          rs485_5.TX_buf[2]  = modbus5.byte_cnt;       //Byte Count
 129   1      
 130   1          for( i = modbus5.start_addr; i < modbus5.start_addr + modbus5.byte_cnt/2; i++ )
 131   1          {
 132   2              /*    每次循环前初始化byte_info                       */
 133   2              modbus5.byte_info_H = modbus5.byte_info_L = 0X00;
 134   2              switch (i)
 135   2              {   
 136   3                  /*  x白边              */
 137   3                  case 0x00:  
 138   3                      modbus5.byte_info_H  = (uint8_t)(hansen.addr_0x00 >> 8);
 139   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x00 & 0xFF);
 140   3      
 141   3                      break;
 142   3                  /*  y白边              */
 143   3                  case 0x02:  
 144   3                      modbus5.byte_info_H  = (uint8_t)(hansen.addr_0x02 >> 8);
 145   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x02 & 0xFF);
 146   3      
 147   3                      break;
 148   3      
 149   3                  /*  获取当前主板语言              */
 150   3                  case 0x06:  
 151   3                      modbus5.byte_info_H  = (uint8_t)(hansen.addr_0x06 >> 8);
 152   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x06 & 0xFF); 
 153   3      
 154   3                      break;
 155   3      
 156   3                  /*  获取当前主板语言              */
 157   3                  case 0x10:  
 158   3                      modbus5.byte_info_H  = 0x00;
 159   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x10 & 0xFF); 
 160   3      
 161   3                      break;
 162   3      
 163   3                  /*  获取当前主板语言              */
 164   3                  case 0x0c:  
 165   3                      modbus5.byte_info_H  = 0x00;
 166   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x0c & 0xFF); 
 167   3      
 168   3                      break;
 169   3      
 170   3                  /*  马达操作                      */
 171   3                  case 0x20:
 172   3                      modbus5.byte_info_H  = (uint8_t)(hansen.addr_0x20 >> 8);
 173   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x20 & 0xFF);
 174   3      
 175   3                      break;
 176   3      
 177   3                  /*  喷头操作                       */    
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 4   

 178   3                  case 0x21:
 179   3                      modbus5.byte_info_H  = (uint8_t)(hansen.addr_0x21 >> 8);
 180   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x21 & 0xFF);
 181   3      
 182   3                      break;
 183   3      
 184   3                  /*  喷头强度                  */
 185   3                  case 0x22:    
 186   3                      modbus5.byte_info_H  = (uint8_t)(hansen.addr_0x22 >> 8);
 187   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x22 & 0xFF); 
 188   3      
 189   3                      break;
 190   3      
 191   3                  /*  喷头数量                 */
 192   3                  case 0x23:   
 193   3                      modbus5.byte_info_H  = (uint8_t)(hansen.addr_0x23 >> 8);
 194   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x23 & 0xFF); 
 195   3      
 196   3                      break;
 197   3      
 198   3                  /*  信号                 */
 199   3                  case 0x2d:    
 200   3                      modbus5.byte_info_H  = (uint8_t)(hansen.addr_0x2d >> 8);
 201   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x2d & 0xFF); 
 202   3      
 203   3                      break;
 204   3      
 205   3                  /*  校准图类型                 */
 206   3                  case 0x30:   
 207   3                      modbus5.byte_info_H  = (uint8_t)(hansen.addr_0x30 >> 8);
 208   3                      modbus5.byte_info_L  = (uint8_t)(hansen.addr_0x30 & 0xFF); 
 209   3      
 210   3                      break; 
 211   3      
 212   3                  default:
 213   3                      break;
 214   3              }
 215   2              rs485_5.TX_buf[modbus5.send_val_addr++] = modbus5.byte_info_H;
 216   2              rs485_5.TX_buf[modbus5.send_val_addr++] = modbus5.byte_info_L;
 217   2          }
 218   1          slave1_to_master(0x03,3 + modbus5.byte_cnt);
 219   1          if( hansen.connect_flag == 0 )
 220   1          {
 221   2              hansen.connect_flag = 1;
 222   2              Write_Dgus(0x2025,1);
 223   2          }
 224   1          
 225   1      }
 226          
 227          void Modbus_Fun06_slave1( void )
 228          {
 229   1          switch(rs485_5.RX_buf[3])
 230   1          {
 231   2              /*  马达操作                      */
 232   2              case 0x20:                         
 233   2                  hansen.addr_0x20 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 234   2      
 235   2                  break;  
 236   2      
 237   2              /*  喷头操作                       */    
 238   2              case 0x21:
 239   2                  hansen.addr_0x21 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 5   

 240   2      
 241   2                  break;
 242   2      
 243   2              /*  喷头强度                  */
 244   2              case 0x22:    
 245   2                  hansen.addr_0x22 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 246   2      
 247   2                  break;
 248   2      
 249   2              /*  喷头数量                 */
 250   2              case 0x23:   
 251   2                  hansen.addr_0x23 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 252   2      
 253   2                  break;
 254   2      
 255   2              /*  信号                 */
 256   2              case 0x2d:    
 257   2                  hansen.addr_0x2d = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 258   2      
 259   2                  break;
 260   2      
 261   2              /*  校准图类型                 */
 262   2              case 0x30:   
 263   2                  hansen.addr_0x30 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 264   2      
 265   2                  break;
 266   2      
 267   2              // /*                    */
 268   2              // case 0x100:   
 269   2              //     //hansen.addr_0x2 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 270   2      
 271   2              //     break;
 272   2      
 273   2              // /*                    */
 274   2              // case 0x101:    
 275   2              //     //hansen.addr_0x24 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 276   2      
 277   2              //     break;
 278   2       
 279   2              // /*                    */
 280   2              // case 0x102:   
 281   2              //     //hansen.addr_0x25 = (rs485_5.RX_buf[4] << 8) | rs485_5.RX_buf[5]; 
 282   2      
 283   2              //     break;
 284   2      
 285   2              default:
 286   2                  break;   
 287   2          }
 288   1      
 289   1          slave1_to_master(FUN_06,8);
 290   1      
 291   1      }
 292          
 293          /**
 294           * @brief 写多个输出寄存器  16
 295           *
 296           * @param   void
 297           *
 298           * @return  void 
 299          **/
 300          void Modbus_Fun16_slave1( void )
 301          {
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 6   

 302   1          uint16_t i;
 303   1          static uint8_t chip_id[32] = {0};
 304   1          static uint8_t FW_set[32] = {0};
 305   1          static uint8_t FW_params[32] = {0};
 306   1          static uint8_t HS_version[30] = {0};
 307   1          static uint8_t renwu_name[32] = {0};
 308   1          static uint8_t dayin_mode[20] = {0};
 309   1      
 310   1          modbus5.rcv_value_addr = 7;                  //DATA1 H位置
 311   1          modbus5.byte_cnt   = rs485_5.RX_buf[6];
 312   1          modbus5.start_addr = rs485_5.RX_buf[2]<<8 | rs485_5.RX_buf[3];
 313   1      
 314   1          for( i = modbus5.start_addr; i < modbus5.start_addr + modbus5.byte_cnt/2; i++)
 315   1          {
 316   2              modbus5.byte_info_H = rs485_5.RX_buf[modbus5.rcv_value_addr];
 317   2              modbus5.byte_info_L = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 318   2              switch (i)
 319   2              {
 320   3                  
 321   3                  /*  0x0100  系统动作    */
 322   3                  case 0x0100:
 323   3                      hansen.addr_0x0100 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 324   3      
 325   3                      switch(hansen.addr_0x0100)
 326   3                      {
 327   4                          
 328   4                          case 0:         hansen.addr_0x20 = 0;   fuyin_flag = 0;                               
             -break;      //清除跑机使能    
 329   4                          case 2:         hansen.addr_0x20 = 0;   Write_Dgus(0x2020,0);                         
             -break;      //清除马达操作使能 
 330   4                          case 3:         hansen.addr_0x30 = 0;                                                 
             -break;      //清除检测使能       
 331   4                          case 6:         hansen.addr_0x21 = 0;   hansen.addr_0x22 = 0;   hansen.addr_0x23 = 0; 
             -break;      //清除清洗、装墨使能         
 332   4                          case 10:        hansen.addr_0x21 = 0;   hansen.addr_0x23 = 0;                         
             -break;      //开始装墨
 333   4                          case 12:        hansen.addr_0x20 = 0;                                                 
             -break;      //开始装墨
 334   4                          default:                                                                              
             -break;      //清除跑机使能      
 335   4                      }
 336   3      
 337   3                      break;
 338   3      
 339   3                  /*  0x0102  打印状态    */
 340   3                  case 0x0102:
 341   3                      hansen.addr_0x0102 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 342   3      
 343   3                      switch(hansen.addr_0x0102)
 344   3                      { 
 345   4                          case 0:         Write_Dgusii_Vp_byChar(0x1600,"  空闲  ",8); 
 346   4                                          hansen.addr_0x2d = 0;
 347   4                                          if( hansen.ctrl_flag == 0 )
 348   4                                          {
 349   5                                              hansen.ctrl_flag = 1;
 350   5                                              jump_page(0);
 351   5                                          }     
 352   4                                          break;
 353   4                          case 1:         if( hansen.ctrl_flag == 0 )
 354   4                                          {
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 7   

 355   5                                              Write_Dgusii_Vp_byChar(0x1600," 初始化 ",8);
 356   5                                          }
 357   4                                          break;     
 358   4                          case 2:         Write_Dgusii_Vp_byChar(0x1600,"  打印  ",8);       
 359   4                                          if( fuyin_flag == 0 )
 360   4                                          { 
 361   5                                              jump_page(11); 
 362   5                                          } 
 363   4                                          break;
 364   4                          case 3:         Write_Dgusii_Vp_byChar(0x1600,"  恢复  ",8);        break;     
 365   4                          case 4:         Write_Dgusii_Vp_byChar(0x1600,"  暂停  ",8);        break;
 366   4                          case 6:         Write_Dgusii_Vp_byChar(0x1600,"  保湿  ",8);        break;    
 367   4                          case 7:         Write_Dgusii_Vp_byChar(0x1600,"其他动作",8);        break;
 368   4                          default:                                                            break;
 369   4                      }
 370   3      
 371   3                      break;
 372   3      
 373   3                  /*  0x0110  总打印份数    */
 374   3                  case 0x0110:
 375   3                      hansen.addr_0x0110 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1]; 
 376   3                      Write_Dgus(0x20ce,hansen.addr_0x0110);   
 377   3                      break;
 378   3      
 379   3                  /*  0x0111  当前打印份数/打印幅数    */    
 380   3                  case 0x0111:
 381   3                      hansen.addr_0x0111 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1]; 
 382   3                      Write_Dgus(0x20cd,hansen.addr_0x0111); 
 383   3                      break;
 384   3      
 385   3                  /*  0x0112  打印精度(XDPI)    */
 386   3                  case 0x0112:
 387   3                      hansen.addr_0x0112 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1]; 
 388   3                      Write_Dgus(0x20c0,hansen.addr_0x0112); 
 389   3                      break;   
 390   3      
 391   3                  /*  0x0114  打印精度(YDPI)    */    
 392   3                  case 0x0114:
 393   3                      hansen.addr_0x0114 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1]; 
 394   3                      Write_Dgus(0x20c2,hansen.addr_0x0114); 
 395   3                      break; 
 396   3      
 397   3                  /*  0x011A  图像宽度（mm）    */  
 398   3                  case 0x011a:
 399   3                      hansen.addr_0x011a = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1]; 
 400   3                      Write_Dgus(0x20c4,hansen.addr_0x011a); 
 401   3                      break;
 402   3      
 403   3                  /*  0x011C  图像高度（mm）    */   
 404   3                  case 0x011c:
 405   3                      hansen.addr_0x011c = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1]; 
 406   3                      Write_Dgus(0x20c6,hansen.addr_0x011c); 
 407   3                      break;
 408   3      
 409   3                  /*  0x0120~124  打印模式    */     
 410   3                  case 0x0120:
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 8   

 411   3                      dayin_mode[0] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 412   3                      dayin_mode[1] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 413   3                      break;
 414   3                  case 0x0121:
 415   3                      dayin_mode[2] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 416   3                      dayin_mode[3] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 417   3                      break;
 418   3                  case 0x0122:
 419   3                      dayin_mode[4] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 420   3                      dayin_mode[5] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 421   3                      break;
 422   3                  case 0x0123:
 423   3                      dayin_mode[6] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 424   3                      dayin_mode[7] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 425   3                      break;
 426   3                  case 0x0124:
 427   3                      dayin_mode[8] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 428   3                      dayin_mode[9] = rs485_5.RX_buf[modbus5.rcv_value_addr]; 
 429   3                      Write_Dgusii_Vp_byChar(0x20b0,dayin_mode,10);           
 430   3                      break;
 431   3      
 432   3                  /*  0x0134  打印计时-秒    */   
 433   3                  case 0x0134:
 434   3                      hansen.addr_0x0134 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 435   3                      time_trans(hansen.addr_0x0134,0);
 436   3      
 437   3                      Write_Dgus(0x20d0,dayin_t.cnt_h); 
 438   3                      Write_Dgus(0x20d1,dayin_t.cnt_min); 
 439   3                      Write_Dgus(0x20d2,dayin_t.cnt_s); 
 440   3                      break;
 441   3                  
 442   3                  /*  0x0136  剩余时间-秒    */    
 443   3                  case 0x0136:
 444   3                      hansen.addr_0x0136 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 445   3                      time_trans(hansen.addr_0x0136,1);
 446   3      
 447   3                      Write_Dgus(0x20d3,dayin_t.remain_h); 
 448   3                      Write_Dgus(0x20d4,dayin_t.remain_min); 
 449   3                      Write_Dgus(0x20d5,dayin_t.remain_s); 
 450   3                      break;
 451   3      
 452   3                  /*  0x0138  打印产能(面积)    */        
 453   3                  case 0x0138:
 454   3                      hansen.addr_0x0138 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 455   3      
 456   3                      Write_Dgus(0x20cc,hansen.addr_0x0138); 
 457   3                      break;
 458   3      
 459   3                  /*  0x013A  打印产能(长度)    */ 
 460   3                  case 0x013a:
 461   3                      hansen.addr_0x013a = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 462   3      
 463   3                      Write_Dgus(0x20c9,hansen.addr_0x013a); 
 464   3                      break;
 465   3      
 466   3                  /*  0x013C  打印产能(长度)    */ 
 467   3                  case 0x013c:
 468   3                      hansen.addr_0x013c = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 9   

             -5.rcv_value_addr + 1];
 469   3                      if( hansen.addr_0x013c == 100 )
 470   3                      {
 471   4                          jump_page(0); 
 472   4                      }
 473   3                      Write_Dgus(0x20d9,hansen.addr_0x013c); 
 474   3                      break;
 475   3      
 476   3                  /*  0x0140~149  PRN任务名称    */    
 477   3                  case 0x0140:
 478   3                      renwu_name[0] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 479   3                      renwu_name[1] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 480   3                      break;
 481   3                  case 0x0141:
 482   3                      renwu_name[2] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 483   3                      renwu_name[3] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 484   3                      break;
 485   3                  case 0x0142:
 486   3                      renwu_name[4] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 487   3                      renwu_name[5] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 488   3                      break;
 489   3                  case 0x0143:
 490   3                      renwu_name[6] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 491   3                      renwu_name[7] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 492   3                      break;
 493   3                  case 0x0144:
 494   3                      renwu_name[8] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 495   3                      renwu_name[9] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 496   3                      break;
 497   3                  case 0x0145:
 498   3                      renwu_name[10] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 499   3                      renwu_name[11] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 500   3                      break;
 501   3                  case 0x0146:
 502   3                      renwu_name[12] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 503   3                      renwu_name[13] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 504   3                      break;
 505   3                  case 0x0147:
 506   3                      renwu_name[14] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 507   3                      renwu_name[15] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 508   3                      break;
 509   3                  case 0x0148:
 510   3                      renwu_name[16] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 511   3                      renwu_name[17] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 512   3                      break;
 513   3                  case 0x0149:
 514   3                      renwu_name[18] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 515   3                      renwu_name[19] = rs485_5.RX_buf[modbus5.rcv_value_addr];     
 516   3                      //Write_Dgusii_Vp_byChar(0x20f0,renwu_name,20);   
 517   3                      break;
 518   3                  
 519   3                  /*  0x0150~151  X马达位置    */ 
 520   3                  case 0x0150:
 521   3                      hansen.addr_0x0150 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 522   3                      break;
 523   3                  case 0x0151:
 524   3                      hansen.addr_0x0151 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 525   3                      Write_Dgus(0x2070,hansen.addr_0x0151);
 526   3                      Write_Dgus(0x2071,hansen.addr_0x0150);
 527   3                      break;
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 10  

 528   3      
 529   3                  /*  0x0152~153  Y马达位置    */     
 530   3                  case 0x0152:
 531   3                      hansen.addr_0x0152 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 532   3                      break;
 533   3                  case 0x0153:
 534   3                      hansen.addr_0x0153 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 535   3                      // Write_Dgus(0x2072,hansen.addr_0x0153);
 536   3                      // Write_Dgus(0x2073,hansen.addr_0x0152);
 537   3                      break;
 538   3      
 539   3                  /*  0x0154~155  Z马达位置    */     
 540   3                  case 0x0154:
 541   3                      hansen.addr_0x0154 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 542   3                      break;
 543   3                  case 0x0155:
 544   3                      hansen.addr_0x0155 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 545   3                      // Write_Dgus(0x2074,hansen.addr_0x0155);
 546   3                      // Write_Dgus(0x2075,hansen.addr_0x0154);
 547   3                      break;
 548   3      
 549   3                  /*  0x0156~157  主板IP    */ 
 550   3                  case 0x0156:
 551   3                      hansen.addr_0x0156_H = rs485_5.RX_buf[modbus5.rcv_value_addr];
 552   3                      hansen.addr_0x0156_L = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 553   3                      break;
 554   3                  case 0x0157:
 555   3                      hansen.addr_0x0157_H = rs485_5.RX_buf[modbus5.rcv_value_addr];
 556   3                      hansen.addr_0x0157_L = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 557   3                      Write_Dgus(0x2080,hansen.addr_0x0156_L);     
 558   3                      Write_Dgus(0x2082,hansen.addr_0x0156_H);    
 559   3                      Write_Dgus(0x2084,hansen.addr_0x0157_L);     
 560   3                      Write_Dgus(0x2086,hansen.addr_0x0157_H);    
 561   3                      break;
 562   3      
 563   3                  /*  0x0158  X白边    */ 
 564   3                  case 0x0158:
 565   3                      hansen.addr_0x00 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus5.
             -rcv_value_addr + 1];
 566   3                      Write_Dgus(0x2060,hansen.addr_0x00);     
 567   3                      break;
 568   3      
 569   3                  /*  0x015A  Y白边    */ 
 570   3                  case 0x015a:
 571   3                      hansen.addr_0x02 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus5.
             -rcv_value_addr + 1];
 572   3                      Write_Dgus(0x2062,hansen.addr_0x02);  
 573   3                      break;
 574   3      
 575   3                  /*  0x015E  打印设置    */ 
 576   3                  case 0x015e:
 577   3                      hansen.addr_0x06 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus5.
             -rcv_value_addr + 1];
 578   3                      
 579   3                      hansen.addr_0x06_02 = hansen.addr_0x06 & 0x04;
 580   3                      if( hansen.addr_0x06_02 == 4 )
 581   3                      {
 582   4                          hansen.addr_0x06_02 = 3;
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 11  

 583   4                      }
 584   3                      hansen.addr_0x06_35 = (hansen.addr_0x06 & 0x38) >> 3;
 585   3                      if( hansen.addr_0x06_35 == 4 )
 586   3                      {
 587   4                          hansen.addr_0x06_35 = 3;
 588   4                      }
 589   3                      hansen.addr_0x06_67 = (hansen.addr_0x06 & 0xc0) >> 6;
 590   3                      hansen.addr_0x06_8a = (hansen.addr_0x06 & 0x0700) >> 8;
 591   3                      if( hansen.addr_0x06_8a == 4 )
 592   3                      {
 593   4                          hansen.addr_0x06_8a = 3;
 594   4                      }
 595   3                      hansen.addr_0x06_bc = (hansen.addr_0x06 & 0x1800) >> 11;
 596   3      
 597   3                      Write_Dgus(0x2051,hansen.addr_0x06_02);  
 598   3                      Write_Dgus(0x2052,hansen.addr_0x06_35);
 599   3                      Write_Dgus(0x2053,hansen.addr_0x06_67);
 600   3                      Write_Dgus(0x2054,hansen.addr_0x06_8a);    
 601   3                      Write_Dgus(0x2055,hansen.addr_0x06_bc);   
 602   3                      break;
 603   3      
 604   3                  /*  0x015F  羽化幅度    */     
 605   3                  case 0x015f:
 606   3                      hansen.addr_yuhua = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus5
             -.rcv_value_addr + 1];
 607   3      
 608   3                      break;
 609   3      
 610   3                  /*  0x015F  当前实际喷头个数    */     
 611   3                  case 0x0160:
 612   3                      hansen.addr_sjpt = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus5.
             -rcv_value_addr + 1];
 613   3      
 614   3                      break;
 615   3      
 616   3                  /*  0x0161  当前清洗类型    */     
 617   3                  case 0x0161:
 618   3                      hansen.addr_0x22 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus5.
             -rcv_value_addr + 1];
 619   3                      if( hansen.addr_0x22 == 4 )
 620   3                      {
 621   4                          hansen.addr_0x22 = 3;
 622   4                      }
 623   3                      Write_Dgus(0x2022,hansen.addr_0x22);
 624   3                      hansen.addr_0x22 = 0;    
 625   3                      break;
 626   3      
 627   3                  /*  0x0162  当前清洗/装墨喷头个数    */     
 628   3                  case 0x0162:
 629   3                      hansen.addr_0x23 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus5.
             -rcv_value_addr + 1];
 630   3                      Write_Dgus(0x2023,hansen.addr_0x23);
 631   3                      hansen.addr_0x23 = 0;  
 632   3                      break;
 633   3      
 634   3                  
 635   3                  /*  40007  同步开关设置                         */
 636   3                  case 0x0169:
 637   3                      hansen.addr_0x0169 = (rs485_5.RX_buf[modbus5.rcv_value_addr] << 8) | rs485_5.RX_buf[modbus
             -5.rcv_value_addr + 1];
 638   3      
 639   3                      switch(hansen.addr_0x0169)
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 12  

 640   3                      {
 641   4                          
 642   4                          case 0  :         hansen.addr_0x10 |= 0x20;           break;         
 643   4                          
 644   4                          default:                                            break;
 645   4                      }
 646   3      
 647   3                      break;
 648   3      
 649   3                  case 0x0170:
 650   3                      HS_version[0] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 651   3                      HS_version[1] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 652   3                      break;
 653   3                  case 0x0171:
 654   3                      HS_version[2] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 655   3                      HS_version[3] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 656   3                      break;
 657   3                  case 0x0172:
 658   3                      HS_version[4] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 659   3                      HS_version[5] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 660   3                      break;
 661   3                  case 0x0173:
 662   3                      HS_version[6] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 663   3                      HS_version[7] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 664   3                      break;
 665   3                  case 0x0174:
 666   3                      HS_version[8] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 667   3                      HS_version[9] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 668   3                      break;
 669   3                  case 0x0175:
 670   3                      HS_version[10] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 671   3                      HS_version[11] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 672   3                      break;
 673   3      
 674   3                  case 0x0176:
 675   3                      HS_version[12] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 676   3                      HS_version[13] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 677   3                      break;
 678   3                  case 0x0177:
 679   3                      HS_version[14] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 680   3                      HS_version[15] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 681   3                      break;
 682   3                  case 0x0178:
 683   3                      HS_version[16] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 684   3                      HS_version[17] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 685   3                      break;
 686   3                  case 0x0179:
 687   3                      HS_version[18] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 688   3                      HS_version[19] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 689   3                      break;
 690   3                  case 0x017a:
 691   3                      HS_version[20] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 692   3                      HS_version[21] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 693   3                      break;
 694   3                  case 0x017b:
 695   3                      HS_version[22] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 696   3                      HS_version[23] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 697   3                      break;
 698   3                  case 0x017c:
 699   3                      HS_version[24] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 700   3                      HS_version[25] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 701   3                      break;
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 13  

 702   3                  case 0x017d:
 703   3                      HS_version[26] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 704   3                      HS_version[27] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 705   3                      break;
 706   3      
 707   3                  case 0x017e:
 708   3                      HS_version[28] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 709   3                      HS_version[29] = rs485_5.RX_buf[modbus5.rcv_value_addr];   
 710   3                      Write_Dgusii_Vp_byChar(0x1630,HS_version,30);       
 711   3                      break;
 712   3      
 713   3                  case 0x0190:
 714   3                      chip_id[0] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 715   3                      chip_id[1] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 716   3                      break;
 717   3                  case 0x0191:
 718   3                      chip_id[2] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 719   3                      chip_id[3] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 720   3                      break;
 721   3                  case 0x0192:
 722   3                      chip_id[4] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 723   3                      chip_id[5] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 724   3                      break;
 725   3                  case 0x0193:
 726   3                      chip_id[6] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 727   3                      chip_id[7] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 728   3                      break;
 729   3                  case 0x0194:
 730   3                      chip_id[8] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 731   3                      chip_id[9] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 732   3                      break;
 733   3                  case 0x0195:
 734   3                      chip_id[10] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 735   3                      chip_id[11] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 736   3                      break;
 737   3      
 738   3                  case 0x0196:
 739   3                      chip_id[12] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 740   3                      chip_id[13] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 741   3                      break;
 742   3                  case 0x0197:
 743   3                      chip_id[14] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 744   3                      chip_id[15] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 745   3                      break;
 746   3                  case 0x0198:
 747   3                      chip_id[16] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 748   3                      chip_id[17] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 749   3                      break;
 750   3                  case 0x0199:
 751   3                      chip_id[18] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 752   3                      chip_id[19] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 753   3                      break;
 754   3                  case 0x019a:
 755   3                      chip_id[20] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 756   3                      chip_id[21] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 757   3                      break;
 758   3                  case 0x019b:
 759   3                      chip_id[22] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 760   3                      chip_id[23] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 761   3                      break;
 762   3                  case 0x019c:
 763   3                      chip_id[24] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 14  

 764   3                      chip_id[25] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 765   3                      break;
 766   3                  case 0x019d:
 767   3                      chip_id[26] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 768   3                      chip_id[27] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 769   3                      break;
 770   3      
 771   3                  case 0x019e:
 772   3                      chip_id[28] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 773   3                      chip_id[29] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 774   3                      break;
 775   3                  case 0x019f:
 776   3                      chip_id[30] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 777   3                      chip_id[31] = rs485_5.RX_buf[modbus5.rcv_value_addr];
 778   3                      Write_Dgusii_Vp_byChar(0x1650,chip_id,32);   
 779   3                      break;
 780   3      
 781   3                  case 0x01c0:
 782   3                      FW_set[0] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 783   3                      FW_set[1] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 784   3                      break;
 785   3                  case 0x01C1:
 786   3                      FW_set[2] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 787   3                      FW_set[3] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 788   3                      break;
 789   3                  case 0x01C2:
 790   3                      FW_set[4] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 791   3                      FW_set[5] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 792   3                      break;
 793   3                  case 0x01C3:
 794   3                      FW_set[6] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 795   3                      FW_set[7] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 796   3                      break;
 797   3                  case 0x01C4:
 798   3                      FW_set[8] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 799   3                      FW_set[9] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 800   3                      break;
 801   3                  case 0x01C5:
 802   3                      FW_set[10] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 803   3                      FW_set[11] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 804   3                      break;
 805   3      
 806   3                  case 0x01C6:
 807   3                      FW_set[12] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 808   3                      FW_set[13] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 809   3                      break;
 810   3                  case 0x01C7:
 811   3                      FW_set[14] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 812   3                      FW_set[15] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 813   3                      break;
 814   3                  case 0x01C8:
 815   3                      FW_set[16] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 816   3                      FW_set[17] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 817   3                      break;
 818   3                  case 0x01C9:
 819   3                      FW_set[18] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 820   3                      FW_set[19] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 821   3                      break;
 822   3                  case 0x01Ca:
 823   3                      FW_set[20] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 824   3                      FW_set[21] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 825   3                      break;
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 15  

 826   3                  case 0x01Cb:
 827   3                      FW_set[22] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 828   3                      FW_set[23] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 829   3                      break;
 830   3                  case 0x01Cc:
 831   3                      FW_set[24] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 832   3                      FW_set[25] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 833   3                      break;
 834   3                  case 0x01Cd:
 835   3                      FW_set[26] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 836   3                      FW_set[27] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 837   3                      break;
 838   3      
 839   3                  case 0x01Ce:
 840   3                      FW_set[28] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 841   3                      FW_set[29] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 842   3                      break;
 843   3                  case 0x01Cf:
 844   3                      FW_set[30] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 845   3                      FW_set[31] = rs485_5.RX_buf[modbus5.rcv_value_addr];
 846   3                      Write_Dgusii_Vp_byChar(0x1670,FW_set,32);   
 847   3                      break;
 848   3      
 849   3                  case 0x01D0:
 850   3                      FW_params[0] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 851   3                      FW_params[1] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 852   3                      break;
 853   3                  case 0x01D1:
 854   3                      FW_params[2] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 855   3                      FW_params[3] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 856   3                      break;
 857   3                  case 0x01D2:
 858   3                      FW_params[4] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 859   3                      FW_params[5] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 860   3                      break;
 861   3                  case 0x01D3:
 862   3                      FW_params[6] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 863   3                      FW_params[7] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 864   3                      break;
 865   3                  case 0x01D4:
 866   3                      FW_params[8] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 867   3                      FW_params[9] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 868   3                      break;
 869   3                  case 0x01D5:
 870   3                      FW_params[10] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 871   3                      FW_params[11] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 872   3                      break;
 873   3      
 874   3                  case 0x01D6:
 875   3                      FW_params[12] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 876   3                      FW_params[13] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 877   3                      break;
 878   3                  case 0x01D7:
 879   3                      FW_params[14] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 880   3                      FW_params[15] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 881   3                      break;
 882   3                  case 0x01D8:
 883   3                      FW_params[16] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 884   3                      FW_params[17] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 885   3                      break;
 886   3                  case 0x01D9:
 887   3                      FW_params[18] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 16  

 888   3                      FW_params[19] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 889   3                      break;
 890   3                  case 0x01Da:
 891   3                      FW_params[20] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 892   3                      FW_params[21] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 893   3                      break;
 894   3                  case 0x01Db:
 895   3                      FW_params[22] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 896   3                      FW_params[23] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 897   3                      break;
 898   3                  case 0x01Dc:
 899   3                      FW_params[24] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 900   3                      FW_params[25] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 901   3                      break;
 902   3                  case 0x01Dd:
 903   3                      FW_params[26] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 904   3                      FW_params[27] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 905   3                      break;
 906   3      
 907   3                  case 0x01De:
 908   3                      FW_params[28] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 909   3                      FW_params[29] = rs485_5.RX_buf[modbus5.rcv_value_addr];        
 910   3                      break;
 911   3                  case 0x01Df:
 912   3                      FW_params[30] = rs485_5.RX_buf[modbus5.rcv_value_addr + 1];
 913   3                      FW_params[31] = rs485_5.RX_buf[modbus5.rcv_value_addr];
 914   3                      Write_Dgusii_Vp_byChar(0x1690,FW_params,32);   
 915   3                      break;    
 916   3                  default:
 917   3                      break;
 918   3              }
 919   2              modbus5.rcv_value_addr += 2;         //从Value1_H →→ 从Value2_H
 920   2          }
 921   1          
 922   1          slave1_to_master(FUN_16,8);  
 923   1      }
 924          
 925          
 926          void Modbus_Fun03_slave2( void )
 927          {
 928   1          uint16_t i = 0;
 929   1      
 930   1          uint8_t start_addr_03 = 3;              //Slave reply  DATA1_H address
 931   1      
 932   1          for( i = 0; i < 9; i++)
 933   1          {
 934   2              switch (i)
 935   2              {
 936   3      
 937   3                  /*  40001 三路220V输出使能设置          */
 938   3                  case 0x00:
 939   3                      sp350.F_switch = rs485_4.RX_buf[start_addr_03 + 1];   
 940   3      
 941   3                      break;
 942   3      
 943   3                  /*  40002   风速12设置                   */
 944   3                  case 0x01:
 945   3                      sp350.M_switch = rs485_4.RX_buf[start_addr_03 + 1];   
 946   3      
 947   3                      break;
 948   3      
 949   3                  /*  40003   风速3设置                   */
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 17  

 950   3                  case 0x02:
 951   3                      sp350.R_switch = rs485_4.RX_buf[start_addr_03 + 1];   
 952   3      
 953   3                      break; 
 954   3      
 955   3                  /*  40004   同步状态设置                */
 956   3                  case 0x03:
 957   3                      sp350.F_alarm_val = rs485_4.RX_buf[start_addr_03 + 1];   
 958   3      
 959   3                      break;
 960   3      
 961   3                  /*  40005   预加热开关              */
 962   3                  case 0x04:
 963   3                      sp350.M_alarm_val = rs485_4.RX_buf[start_addr_03 + 1];   
 964   3      
 965   3                      break;   
 966   3      
 967   3                  /*  40006   预加热温度设置              */
 968   3                  case 0x05:
 969   3                      sp350.R_alarm_val = rs485_4.RX_buf[start_addr_03 + 1];   
 970   3      
 971   3                      break;   
 972   3      
 973   3                  /*  40007   预加热时间设置              */
 974   3                  case 0x06:
 975   3                      sp350.LED_switch = rs485_4.RX_buf[start_addr_03 + 1];   
 976   3      
 977   3                      break; 
 978   3      
 979   3                  /*  40008   负载总功率设置              */
 980   3                  case 0x07:
 981   3                      sp350.fan_level = rs485_4.RX_buf[start_addr_03 + 1];   
 982   3      
 983   3                      break; 
 984   3      
 985   3                  /*  40009   报警温度设置               */
 986   3                  case 0x08:
 987   3                      sp350.fan_switch = rs485_4.RX_buf[start_addr_03 + 1];   
 988   3      
 989   3                      break; 
 990   3      
 991   3                  default:
 992   3                      break;
 993   3              }
 994   2              start_addr_03 += 2;
 995   2          }
 996   1      
 997   1          if( sp350.params_get_flag1 == 1 )
 998   1          {
 999   2              sp350.params_get_flag1 = 0;
1000   2              sp350_parms_init();
1001   2          }
1002   1          
1003   1      }
1004          
1005          /**
1006           * @brief 写单个输出寄存器-06
1007           *
1008           * @param   reg_addr：要写的寄存器地址
1009           *          reg_val： 要写的值
1010           *
1011           * @return  void
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 18  

1012           */
1013          void write_slave_06(uint16_t reg_addr, uint8_t reg_val_H, uint8_t reg_val_L)
1014          {
1015   1          uint8_t send_buf[8];
1016   1          uint16_t crc;
1017   1      
1018   1          delay_ms(10);
1019   1          download_flag = 0;
1020   1      
1021   1          send_buf[0] = SP350P_ADDR;       //Addr
1022   1          send_buf[1] = FUN_06;           //Fun
1023   1      
1024   1          /*   Value_H  && Value_L    */
1025   1          send_buf[2] = reg_addr >> 8;
1026   1          send_buf[3] = reg_addr;
1027   1          send_buf[4] = reg_val_H ;
1028   1          send_buf[5] = reg_val_L;
1029   1      
1030   1          /*   crc    */
1031   1          crc = MODBUS_CRC16(send_buf,6);
1032   1          send_buf[6] = crc >> 8;
1033   1          send_buf[7] = crc;
1034   1      
1035   1          memcpy(rs485_4.TX_buf,send_buf,8);
1036   1          /*   发送，后使能接收    */
1037   1          rs485_4.TX_send_bytelength = 8;
1038   1      
1039   1          TR4 = 1;
1040   1      
1041   1          delay_ms(2);
1042   1          SCON2T |= S4TI;                             //开始发送
1043   1          delay_ms(1);
1044   1      }
1045          
1046          /**
1047           * @brief 写单个输出寄存器-03
1048           *
1049           * @param   reg_addr：要写的寄存器地址
1050           *          reg_val： 要写的值
1051           *
1052           * @return  void
1053           */
1054          void get_slave_03( void )
1055          {
1056   1          uint8_t send_buf[8];
1057   1          uint16_t crc;
1058   1      
1059   1          delay_ms(10);
1060   1      
1061   1          send_buf[0] = SP350P_ADDR;       //Addr
1062   1          send_buf[1] = FUN_03;           //Fun
1063   1      
1064   1          /*   Value_H  && Value_L    */
1065   1          send_buf[2] = 0x00;
1066   1          send_buf[3] = 0x00;
1067   1          send_buf[4] = 0x00 ;
1068   1          send_buf[5] = 0x09;
1069   1      
1070   1          /*   crc    */
1071   1          crc = MODBUS_CRC16(send_buf,6);
1072   1          send_buf[6] = crc >> 8;
1073   1          send_buf[7] = crc;
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 19  

1074   1      
1075   1          memcpy(rs485_4.TX_buf,send_buf,8);
1076   1          /*   发送，后使能接收    */
1077   1          rs485_4.TX_send_bytelength = 8;
1078   1      
1079   1          TR4 = 1;
1080   1      
1081   1          delay_ms(2);
1082   1          SCON2T |= S4TI;                             //开始发送
1083   1          delay_ms(1);
1084   1      }
1085          
1086          /**
1087           * @brief 从机回复主机
1088           *  
1089           * @param   code_num:功能码       
1090           * @param   length:数据长度        
1091           * 
1092            @return  crc16:crc校验的值 2byte
1093           */
1094          void slave1_to_master(uint8_t code_num, uint8_t length)
1095          {
1096   1          uint16_t crc;
1097   1      
1098   1          switch(code_num)
1099   1          {
1100   2              case 0x03:
1101   2                  crc = MODBUS_CRC16(rs485_5.TX_buf,length);
1102   2      
1103   2                  // rs485_5.TX_buf[length+1] = crc;             //CRC H
1104   2                  // rs485_5.TX_buf[length] = crc>>8;            //CRC L
1105   2      
1106   2                  rs485_5.TX_buf[length] = crc;             //CRC H
1107   2                  rs485_5.TX_buf[length+1] = crc>>8;            //CRC L
1108   2                  
1109   2                  rs485_5.TX_send_bytelength = length + 2;
1110   2                  
1111   2                  break;
1112   2      
1113   2              case 0x04:
1114   2                  crc = MODBUS_CRC16(rs485_5.TX_buf,length);
1115   2      
1116   2                  rs485_5.TX_buf[length+1] = crc;              //CRC H
1117   2                  rs485_5.TX_buf[length] = crc>>8;             //CRC L
1118   2      
1119   2                  rs485_5.TX_send_bytelength = length + 2;
1120   2                  
1121   2                  break;    
1122   2      
1123   2              case 0x06:
1124   2                  memcpy(rs485_5.TX_buf,rs485_5.RX_buf,length);
1125   2                  rs485_5.TX_send_bytelength = length;
1126   2      
1127   2                  break;    
1128   2      
1129   2              case 0x10:
1130   2                  memcpy(rs485_5.TX_buf,rs485_5.RX_buf,6);
1131   2              
1132   2                  crc = MODBUS_CRC16(rs485_5.TX_buf,6);
1133   2      
1134   2                  rs485_5.TX_buf[6] = crc;                 //CRC H
1135   2                  rs485_5.TX_buf[7] = crc>>8;              //CRC L
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 20  

1136   2              
1137   2                  rs485_5.TX_send_bytelength = length;
1138   2                  
1139   2                  break; 
1140   2      
1141   2              default:
1142   2                  break;
1143   2          }
1144   1      
1145   1          TR5 = 1;                                //485可以发送
1146   1          delay_ms(2);
1147   1          SCON3T |= S5TI;                             //开始发送
1148   1          delay_ms(1);
1149   1      }
1150          
1151          /**
1152           * @brief 从机回复主机
1153           *  
1154           * @param   code_num:功能码       
1155           * @param   length:数据长度        
1156           * 
1157            @return  crc16:crc校验的值 2byte
1158           */
1159          void slave2_to_master(uint8_t code_num, uint8_t length)
1160          {
1161   1          uint16_t crc;
1162   1      
1163   1          switch(code_num)
1164   1          {
1165   2              case 0x03:
1166   2                  crc = MODBUS_CRC16(rs485_4.TX_buf,length);
1167   2      
1168   2                  // rs485_4.TX_buf[length+1] = crc;             //CRC H
1169   2                  // rs485_4.TX_buf[length] = crc>>8;            //CRC L
1170   2      
1171   2                  rs485_4.TX_buf[length] = crc;             //CRC H
1172   2                  rs485_4.TX_buf[length+1] = crc>>8;            //CRC L
1173   2                  
1174   2                  rs485_4.TX_send_bytelength = length + 2;
1175   2                  
1176   2                  break;
1177   2      
1178   2              case 0x04:
1179   2                  crc = MODBUS_CRC16(rs485_4.TX_buf,length);
1180   2      
1181   2                  rs485_4.TX_buf[length+1] = crc;              //CRC H
1182   2                  rs485_4.TX_buf[length] = crc>>8;             //CRC L
1183   2      
1184   2                  rs485_4.TX_send_bytelength = length + 2;
1185   2                  
1186   2                  break;    
1187   2      
1188   2              case 0x06:
1189   2                  memcpy(rs485_4.TX_buf,rs485_4.RX_buf,length);
1190   2                  rs485_4.TX_send_bytelength = length;
1191   2      
1192   2                  break;    
1193   2      
1194   2              case 0x10:
1195   2                  memcpy(rs485_4.TX_buf,rs485_4.RX_buf,6);
1196   2              
1197   2                  crc = MODBUS_CRC16(rs485_4.TX_buf,6);
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 21  

1198   2      
1199   2                  rs485_4.TX_buf[6] = crc;                 //CRC H
1200   2                  rs485_4.TX_buf[7] = crc>>8;              //CRC L
1201   2              
1202   2                  rs485_4.TX_send_bytelength = length;
1203   2                  
1204   2                  break; 
1205   2      
1206   2              default:
1207   2                  break;
1208   2          }
1209   1      
1210   1          TR4 = 1;                                //485可以发送
1211   1          delay_ms(2);
1212   1          SCON2T |= S4TI;                             //开始发送
1213   1          delay_ms(1);
1214   1      }
1215          
1216          /**
1217           * @brief crc校验函数
1218           * 
1219           * @param   buf：  Address(1 byte) +Funtion(1 byte) ）+Data(n byte)   
1220           * @param   length:数据长度           
1221           * 
1222            @return  crc16:crc校验的值 2byte
1223           */
1224          uint16_t MODBUS_CRC16(uint8_t *buf, uint16_t length)
1225          {
1226   1        uint8_t i;
1227   1        uint16_t  crc16;
1228   1      
1229   1          /* 1, 预置16位CRC寄存器为0xffff（即全为1）                          */
1230   1        crc16 = 0xffff; 
1231   1      
1232   1        do
1233   1        {
1234   2              /* 2, 把8位数据与16位CRC寄存器的低位相异或，把结果放于CRC寄存器     */        
1235   2          crc16 ^= (uint16_t)*buf;    //
1236   2          for(i=0; i<8; i++)    
1237   2          {
1238   3                  /* 3, 如果最低位为1，把CRC寄存器的内容右移一位(朝低位)，用0填补最高位 再异或0xA001    */
1239   3            if(crc16 & 1)
1240   3                  {
1241   4                      crc16 = (crc16 >> 1) ^ 0xA001;
1242   4                  }
1243   3                  /* 4, 如果最低位为0，把CRC寄存器的内容右移一位(朝低位)，用0填补最高位                */
1244   3                  else
1245   3                  {
1246   4                      crc16 >>= 1;
1247   4                  }   
1248   3          }
1249   2          buf++;
1250   2        }while(--length != 0);
1251   1      
1252   1        return  (crc16);
1253   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7773    ----
   CONSTANT SIZE    =     63    ----
   XDATA SIZE       =    197      34
C51 COMPILER V9.60.7.0   MODBUS                                                            10/24/2025 16:55:10 PAGE 22  

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
