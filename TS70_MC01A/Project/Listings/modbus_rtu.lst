C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        11/10/2025 17:15:53 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MODBUS_RTU
OBJECT MODULE PLACED IN ..\Output\modbus_rtu.obj
COMPILER INVOKED BY: D:\APP\KEIL\MDK\C51\BIN\C51.EXE ..\Emembed\Src\modbus_rtu.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.
                    -.\BSP\Inc;..\Core\Inc;..\Driver;..\Emembed\Inc;..\SYSTEM\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\modbus_rtu.lst) TABS(2
                    -) OBJECT(..\Output\modbus_rtu.obj)

line level    source

   1          #include "modbus_rtu.h"
   2          
   3          MODBIS_INFO modbus;
   4          
   5          /**
   6           * @brief modbus_rtu  无奇偶校验
   7           *
   8           * @param   void
   9           *
  10           * @return  void 
  11          **/
  12          void Modbus_Event( void )
  13          {
  14   1          uint16_t crc,rccrc;
  15   1          
  16   1          /*1.接收完毕                                           */
  17   1          if( rs485_4.rcv_end_flag == 1 )
  18   1          {
  19   2              /*2.CRC校验                                         */
  20   2              crc = MODBUS_CRC16(rs485_4.rcv_buf, rs485_4.rcv_cnt - 2);
  21   2              rccrc = (rs485_4.rcv_buf[rs485_4.rcv_cnt - 1]) | (rs485_4.rcv_buf[rs485_4.rcv_cnt - 2] << 8);
  22   2              
  23   2      
  24   2              /*3.CRC校验通过，进行地址域校验                      */
  25   2              if( crc == rccrc )
  26   2              {
  27   3                  /*3-1.地址域校验通过，进入相应功能函数进行处理      */
  28   3                  if( rs485_4.rcv_buf[0] == MY_ADDR )
  29   3                  {
  30   4                      switch (rs485_4.rcv_buf[1])
  31   4                      {
  32   5                          case FUN_03:      Modbus_Fun3();      break;
  33   5                          case FUN_04:      Modbus_Fun4();      break;
  34   5                          case FUN_06:      Modbus_Fun6();      break;
  35   5      
  36   5                          default:                            break;
  37   5                      }
  38   4                  }
  39   3              }
  40   2              /*4.清空接收完毕标志位  清空接收计数        */    
  41   2              rs485_4.rcv_end_flag = 0;
  42   2              rs485_4.rcv_cnt = 0; 
  43   2          }
  44   1      }
  45          
  46          /**
  47           * @brief 读输入寄存器  03
  48           *
  49           * @param   void
  50           *
  51           * @return  void 
  52          **/
  53          void Modbus_Fun3( void )
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        11/10/2025 17:15:53 PAGE 2   

  54          {
  55   1          uint16_t i;
  56   1      
  57   1          modbus.rcv_addr1_valH  = 3;                //DATA1 H 位置
  58   1          modbus.start_reg_03    = rs485_4.rcv_buf[2] << 8 | rs485_4.rcv_buf[3];
  59   1          modbus.reg_num_03      = rs485_4.rcv_buf[4] << 8 | rs485_4.rcv_buf[5];
  60   1      
  61   1          rs485_4.send_buf[0]  = MY_ADDR;                  //Addr
  62   1          rs485_4.send_buf[1]  = FUN_03;                   //Fun
  63   1          rs485_4.send_buf[2]  = modbus.reg_num_03 * 2;    //Byte Count
  64   1      
  65   1          for( i = modbus.start_reg_03; i < modbus.start_reg_03 + modbus.reg_num_03; i++ )
  66   1          {
  67   2              switch (i)
  68   2              {             
  69   3                  /*  40001 后烘干开关    */
  70   3                  case 0x00:  
  71   3                      modbus.byte_info_H  = 0x00;
  72   3                      modbus.byte_info_L  = slave_06.PostDry_switch;  
  73   3                      break;
  74   3      
  75   3                  /*  40002 后烘干加热温度                      */
  76   3                  case 0x01:
  77   3                      modbus.byte_info_H  = 0x00;
  78   3                      modbus.byte_info_L  = slave_06.PostDry_temp;; 
  79   3                      break;
  80   3      
  81   3                  /*  40003 撒粉开关及方向    */
  82   3                  case 0x02:  
  83   3                      modbus.byte_info_H  = slave_06.SF_direction;
  84   3                      modbus.byte_info_L  = slave_06.SF_switch;  
  85   3                      break;
  86   3      
  87   3                  /*  40004 撒粉功率                      */
  88   3                  case 0x03:
  89   3                      modbus.byte_info_H  = 0x00;
  90   3                      modbus.byte_info_L  = slave_06.SF_level;; 
  91   3                      break;
  92   3      
  93   3                  /*  40005 抖粉开关及方向                  */    
  94   3                  case 0x04:
  95   3                      modbus.byte_info_H  = slave_06.DF_direction;
  96   3                      modbus.byte_info_L  = slave_06.DF_switch; 
  97   3                      break;
  98   3       
  99   3                  /*  40006 抖粉功率                        */
 100   3                  case 0x05:    
 101   3                      modbus.byte_info_H  = 0x00;
 102   3                      modbus.byte_info_L  = slave_06.DF_level;; 
 103   3                      break;
 104   3      
 105   3                  /*  40007 吸风开关                      */
 106   3                  case 0x06:   
 107   3                      modbus.byte_info_H  = slave_06.IW2_switch;
 108   3                      modbus.byte_info_L  = slave_06.IW1_switch; 
 109   3                      break;
 110   3                      
 111   3                  /*  40008 冷风开关                      */
 112   3                  case 0x07:   
 113   3                      modbus.byte_info_H  = 0X00;
 114   3                      modbus.byte_info_L  = slave_06.CW_switch; 
 115   3                      break;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        11/10/2025 17:15:53 PAGE 3   

 116   3      
 117   3                  /*  40009 收料开关                      */
 118   3                  case 0x08:   
 119   3                      modbus.byte_info_H  = 0X00; 
 120   3                      modbus.byte_info_L  = slave_06.MR_switch; 
 121   3                      break;
 122   3      
 123   3                  /*  40010 保温开关                      */
 124   3                  case 0x09:   
 125   3                      modbus.byte_info_H  = 0X00;
 126   3                      modbus.byte_info_L  = slave_06.Insulation_switch; 
 127   3                      break;
 128   3      
 129   3                  /*  400011 保温温度                      */
 130   3                  case 0x0a:   
 131   3                      modbus.byte_info_H  = 0X00; 
 132   3                      modbus.byte_info_L  = slave_06.Insulation_temp; 
 133   3                      break;
 134   3      
 135   3                  /*  40012 同步开关                      */
 136   3                  case 0x0b:   
 137   3                      modbus.byte_info_H  = 0X00; 
 138   3                      modbus.byte_info_L  = slave_06.sync_switch; 
 139   3                      break;
 140   3      
 141   3                  /*  40013 总开关                      */
 142   3                  case 0x0c:   
 143   3                      modbus.byte_info_H  = 0X00; 
 144   3                      modbus.byte_info_L  = slave_06.power_switch; 
 145   3                      break;
 146   3      
 147   3                  default:
 148   3                      modbus.byte_info_H = 0x00;
 149   3                      modbus.byte_info_L = 0x00;
 150   3                      break;
 151   3              }
 152   2              rs485_4.send_buf[modbus.rcv_addr1_valH++] = modbus.byte_info_H;
 153   2              rs485_4.send_buf[modbus.rcv_addr1_valH++] = modbus.byte_info_L;
 154   2          }
 155   1          slave_to_master(FUN_03,3 + modbus.reg_num_03 * 2);
 156   1      }
 157          
 158          /**
 159           * @brief 读输出寄存器  04
 160           *
 161           * @param   void
 162           *
 163           * @return  void 
 164          **/
 165          void Modbus_Fun4( void )
 166          {
 167   1          uint16_t i;
 168   1      
 169   1          modbus.rcv_addr1_valH  = 3;                    //DATA1 H 位置
 170   1          modbus.start_reg_04 = rs485_4.rcv_buf[2] << 8 | rs485_4.rcv_buf[3];
 171   1          modbus.reg_num_04   = rs485_4.rcv_buf[4] << 8 | rs485_4.rcv_buf[5];
 172   1      
 173   1          rs485_4.send_buf[0]  = MY_ADDR;                  //Addr
 174   1          rs485_4.send_buf[1]  = FUN_04;                   //Fun
 175   1          rs485_4.send_buf[2]  = modbus.reg_num_04 * 2;    //Byte Count
 176   1      
 177   1          for( i = modbus.start_reg_04; i < modbus.start_reg_04 + modbus.reg_num_04; i++ )
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        11/10/2025 17:15:53 PAGE 4   

 178   1          {
 179   2              switch (i)
 180   2              {
 181   3                  /*  30001  热电偶温度                       */
 182   3                  case 0x00:
 183   3                      modbus.byte_info_H = temp.th_temp >> 8;
 184   3                      modbus.byte_info_L = temp.th_temp;
 185   3                      break;
 186   3      
 187   3                  default:
 188   3                      modbus.byte_info_H = 0X00;
 189   3                      modbus.byte_info_L = 0X00;
 190   3                      break;
 191   3              }
 192   2              rs485_4.send_buf[modbus.rcv_addr1_valH++] = modbus.byte_info_H;
 193   2              rs485_4.send_buf[modbus.rcv_addr1_valH++] = modbus.byte_info_L;
 194   2          }
 195   1          slave_to_master(FUN_04,3 + modbus.reg_num_04 * 2);
 196   1      }
 197          
 198          /**
 199           * @brief 写单个输出寄存器  06
 200           *
 201           * @param   void
 202           *
 203           * @return  void 
 204          **/
 205          void Modbus_Fun6( void )
 206          {
 207   1          modbus.reg_addr_06 = rs485_4.rcv_buf[2] << 8 | rs485_4.rcv_buf[3];
 208   1          modbus.byte_info_H = rs485_4.rcv_buf[4];
 209   1          modbus.byte_info_L = rs485_4.rcv_buf[5];
 210   1      
 211   1          switch (rs485_4.rcv_buf[3])
 212   1          {
 213   2              /*  40001   后烘干开关                   */
 214   2              case 0x00:
 215   2                  slave_06.PostDry_switch = modbus.byte_info_L;   
 216   2      
 217   2                  break;
 218   2      
 219   2              /*  40002   后烘干温度                   */
 220   2              case 0x01:
 221   2                  slave_06.PostDry_temp = modbus.byte_info_L;   
 222   2      
 223   2                  break; 
 224   2      
 225   2              /*  40003   撒粉开关及方向                   */
 226   2              case 0x02:
 227   2                  slave_06.SF_direction = modbus.byte_info_H;   
 228   2                  slave_06.SF_switch    = modbus.byte_info_L;   
 229   2      
 230   2                  break;
 231   2      
 232   2              /*  40004   撒粉功率                   */
 233   2              case 0x03:
 234   2                  slave_06.SF_level = modbus.byte_info_L;   
 235   2      
 236   2                  break; 
 237   2      
 238   2              /*  40005   抖粉开关及方向                */
 239   2              case 0x04:
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        11/10/2025 17:15:53 PAGE 5   

 240   2                  slave_06.DF_direction = modbus.byte_info_H;   
 241   2                  slave_06.DF_switch    = modbus.byte_info_L;   
 242   2      
 243   2                  break;
 244   2      
 245   2              /*  40006   抖粉功率              */
 246   2              case 0x05:
 247   2                  slave_06.DF_level = modbus.byte_info_L;   
 248   2      
 249   2                  break;   
 250   2      
 251   2              /*  40007   吸风开关              */
 252   2              case 0x06:
 253   2                  slave_06.IW2_switch = modbus.byte_info_H;  
 254   2                  slave_06.IW1_switch = modbus.byte_info_L;   
 255   2                  break;   
 256   2      
 257   2              /*  40008   冷风开关              */
 258   2              case 0x07:
 259   2                  slave_06.CW_switch = modbus.byte_info_L;   
 260   2                  break; 
 261   2      
 262   2              /*  40009   收料开关              */
 263   2              case 0x08:
 264   2                  slave_06.MR_switch = modbus.byte_info_L;   
 265   2                  break; 
 266   2      
 267   2              /*  40010   保温开关               */
 268   2              case 0x09:
 269   2                  slave_06.Insulation_switch = modbus.byte_info_L;   
 270   2                  break; 
 271   2      
 272   2              /*  40011   保温温度              */
 273   2              case 0x0a:
 274   2                  slave_06.Insulation_temp = modbus.byte_info_L;   
 275   2      
 276   2                  break; 
 277   2      
 278   2              /*  40012   同步开关              */
 279   2              case 0x0b:
 280   2                  slave_06.sync_switch = modbus.byte_info_L;   
 281   2      
 282   2                  break; 
 283   2      
 284   2              /*  40013   总开关               */
 285   2              case 0x0c:
 286   2                  slave_06.power_switch = modbus.byte_info_L;   
 287   2      
 288   2                  break; 
 289   2      
 290   2              default:
 291   2                  break;
 292   2          }
 293   1      
 294   1          slave_to_master(FUN_06,8);
 295   1      
 296   1          eeprom_data_record();
 297   1      }
 298          
 299          
 300          /**
 301           * @brief 从机回复主机
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        11/10/2025 17:15:53 PAGE 6   

 302           *  
 303           * @param   code_num:功能码       
 304           * @param   length:数据长度        
 305           * 
 306            @return  crc16:crc校验的值 2byte
 307           */
 308          void slave_to_master(uint8_t code_num,uint8_t length)
 309          {
 310   1          uint16_t crc;
 311   1      
 312   1          switch (code_num)
 313   1          {
 314   2              case FUN_03:
 315   2                  crc = MODBUS_CRC16(rs485_4.send_buf,length);
 316   2      
 317   2                  rs485_4.send_buf[length + 1] = crc;             //CRC H
 318   2                  rs485_4.send_buf[length]     = crc >> 8;            //CRC L
 319   2      
 320   2                  rs485_4.send_bytelength = length + 2;
 321   2                  
 322   2                  break;
 323   2              case FUN_04:
 324   2                  crc = MODBUS_CRC16(rs485_4.send_buf,length);
 325   2      
 326   2                  rs485_4.send_buf[length + 1] = crc;             //CRC H
 327   2                  rs485_4.send_buf[length]     = crc >> 8;            //CRC L
 328   2      
 329   2      
 330   2                  rs485_4.send_bytelength = length + 2;
 331   2                  
 332   2                  break;    
 333   2      
 334   2              case FUN_06:
 335   2                  memcpy(rs485_4.send_buf,rs485_4.rcv_buf,8);
 336   2      
 337   2                  rs485_4.send_bytelength = length;
 338   2                  
 339   2                  break;    
 340   2      
 341   2              // case 0x10:
 342   2              //     memcpy(rs485_4.send_buf,rs485_4.rcv_buf,6);
 343   2              
 344   2              //     crc = MODBUS_CRC16(rs485_4.send_buf,6);
 345   2      
 346   2              //     rs485_4.send_buf[7] = crc;                 //CRC H
 347   2              //     rs485_4.send_buf[6] = crc>>8;              //CRC L
 348   2              
 349   2              //     rs485_4.send_bytelength = length;
 350   2                  
 351   2              //     break; 
 352   2      
 353   2              default:
 354   2                  break;
 355   2          }
 356   1      
 357   1          DR4_485 = 1;                                 //485可以发送
 358   1          S4CON |= S4TI;                              //开始发送
 359   1          delay_ms(2);
 360   1      }
 361          
 362          /**
 363           * @brief crc校验函数
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        11/10/2025 17:15:53 PAGE 7   

 364           * 
 365           * @param   buf：  Address(1 byte) +Funtion(1 byte) ）+Data(n byte)   
 366           * @param   length:数据长度           
 367           * 
 368            @return  crc16:crc校验的值 2byte
 369           */
 370          uint16_t MODBUS_CRC16(uint8_t *buf, uint8_t length)
 371          {
 372   1        uint8_t i;
 373   1        uint16_t  crc16;
 374   1      
 375   1          /* 1, 预置16位CRC寄存器为0xffff（即全为1）                          */
 376   1        crc16 = 0xffff; 
 377   1      
 378   1        do
 379   1        {
 380   2              /* 2, 把8位数据与16位CRC寄存器的低位相异或，把结果放于CRC寄存器     */    
             -    
 381   2          crc16 ^= (uint16_t)*buf;    //
 382   2          for(i=0; i<8; i++)    
 383   2          {
 384   3                  /* 3, 如果最低位为1，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位 再异或0xA001    */
 385   3            if(crc16 & 1)
 386   3                  {
 387   4                      crc16 = (crc16 >> 1) ^ 0xA001;
 388   4                  }
 389   3                  /* 4, 如果最低位为0，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位                */
 390   3                  else
 391   3                  {
 392   4                      crc16 >>= 1;
 393   4                  }   
 394   3          }
 395   2          buf++;
 396   2        }while(--length != 0);
 397   1      
 398   1        return  (crc16);
 399   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1155    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     17       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
