C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        09/24/2025 09:13:48 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MODBUS_RTU
OBJECT MODULE PLACED IN ..\Output\modbus_rtu.obj
COMPILER INVOKED BY: D:\APP\KEIL\MDK\C51\BIN\C51.EXE ..\Emembed\Src\modbus_rtu.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.
                    -.\BSP\Inc;..\Core\Inc;..\Driver;..\Emembed\Inc;..\SYSTEM\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\modbus_rtu.lst) TABS(2
                    -) OBJECT(..\Output\modbus_rtu.obj)

line level    source

   1          #include "modbus_rtu.h"
   2          
   3          MODBIS_INFO modbus;
   4          
   5          /**
   6           * @brief modbus_rtu  无奇偶校验
   7           *
   8           * @param   void
   9           *
  10           * @return  void 
  11          **/
  12          void Modbus_Event( void )
  13          {
  14   1          uint16_t crc,rccrc;
  15   1          
  16   1          /*1.接收完毕                                           */
  17   1          if( rs485.RX4_rev_end_Flag == 1 )
  18   1          {
  19   2              /*2.清空接收完毕标志位                              */    
  20   2              rs485.RX4_rev_end_Flag = 0;
  21   2      
  22   2              /*3.CRC校验                                         */
  23   2              crc = MODBUS_CRC16(rs485.RX4_buf, rs485.RX4_rev_cnt-2);
  24   2              rccrc = (rs485.RX4_buf[rs485.RX4_rev_cnt - 1]) | (rs485.RX4_buf[rs485.RX4_rev_cnt -2 ] << 8);
  25   2              /*4.清空接收计数                                    */
  26   2              rs485.RX4_rev_cnt = 0; 
  27   2      
  28   2              /*5.CRC校验通过，进行地址域校验                      */
  29   2              if( crc == rccrc )
  30   2              {
  31   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  32   3                  if( rs485.RX4_buf[0] == MY_ADDR )
  33   3                  {
  34   4                      switch ( rs485.RX4_buf[1] )
  35   4                      {
  36   5                          case 0x03:      Modbus_Fun3();      break;
  37   5                          case 0x04:      Modbus_Fun4();      break;
  38   5                          case 0x06:      Modbus_Fun6();      break;
  39   5      
  40   5                          default:                            break;
  41   5                      }
  42   4                  }
  43   3              }
  44   2          }
  45   1      }
  46          
  47          
  48          
  49          /**
  50           * @brief 读输入寄存器  03
  51           *
  52           * @param   void
  53           *
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        09/24/2025 09:13:48 PAGE 2   

  54           * @return  void 
  55          **/
  56          void Modbus_Fun3( void )
  57          {
  58   1          uint16_t i;
  59   1      
  60   1          modbus.send_value_addr  = 3;                //DATA1 H 位置
  61   1          modbus.byte_cnt   = (rs485.RX4_buf[4]<<8 | rs485.RX4_buf[5]) *2;
  62   1          modbus.start_addr = rs485.RX4_buf[2]<<8 | rs485.RX4_buf[3];
  63   1      
  64   1          rs485.TX4_buf[0]  = MY_ADDR;                //Addr
  65   1          rs485.TX4_buf[1]  = 0x03;                   //Fun
  66   1          rs485.TX4_buf[2]  = modbus.byte_cnt;        //Byte Count
  67   1      
  68   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
  69   1          {
  70   2              /*    每次循环前初始化byte_info                       */
  71   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
  72   2              switch (i)
  73   2              {   
  74   3                  /*  40001 热电偶预加热和加热停止温度    */
  75   3                  case 0x00:  
  76   3                      modbus.byte_info_H  = slave_06.tc_preheat_temp;
  77   3                      modbus.byte_info_L  = slave_06.tc_alarm_temp;  
  78   3                      
  79   3                      break;
  80   3      
  81   3                  /*  40002 撒粉功率                      */
  82   3                  case 0x01:
  83   3                      modbus.byte_info_H  = 0x00;
  84   3                      modbus.byte_info_L  = slave_06.sf_level;; 
  85   3      
  86   3                      break;
  87   3      
  88   3                  /*  40003 抖粉功率                      */    
  89   3                  case 0x02:
  90   3                      modbus.byte_info_H  = 0X00;
  91   3                      modbus.byte_info_L  = slave_06.df_level; 
  92   3      
  93   3                      break;
  94   3       
  95   3                  /*  40004 吸风开关                      */
  96   3                  case 0x03:    
  97   3                      modbus.byte_info_H  = slave_06.iw2_switch;
  98   3                      modbus.byte_info_L  = slave_06.iw1_switch;; 
  99   3      
 100   3                      break;
 101   3      
 102   3                  /*  40005 冷风开关                      */
 103   3                  case 0x04:   
 104   3                      modbus.byte_info_H  = 0X00;
 105   3                      modbus.byte_info_L  = slave_06.cw_switch; 
 106   3      
 107   3                      break;
 108   3                      
 109   3                  /*  40006 收料开关                      */
 110   3                  case 0x05:   
 111   3                      modbus.byte_info_H  = 0X00;
 112   3                      modbus.byte_info_L  = slave_06.mr_switch; 
 113   3                      break;
 114   3      
 115   3                  /*  40007 同步开关                      */
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        09/24/2025 09:13:48 PAGE 3   

 116   3                  case 0x06:   
 117   3                      modbus.byte_info_H  = 0X00; 
 118   3                      modbus.byte_info_L  = slave_06.sync_switch; 
 119   3                      break;
 120   3      
 121   3                  default:
 122   3                      break;
 123   3              }
 124   2              rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 125   2              rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 126   2          }
 127   1          slave_to_master(0x03,3 + modbus.byte_cnt);
 128   1      }
 129          
 130          /**
 131           * @brief 读输出寄存器  04
 132           *
 133           * @param   void
 134           *
 135           * @return  void 
 136          **/
 137          void Modbus_Fun4( void )
 138          {
 139   1          uint16_t i;
 140   1      
 141   1          modbus.send_value_addr  = 3;                 //DATA1 H 位置
 142   1          modbus.byte_cnt   = (rs485.RX4_buf[4]<<8 | rs485.RX4_buf[5]) *2;
 143   1          modbus.start_addr = rs485.RX4_buf[2]<<8 | rs485.RX4_buf[3];
 144   1      
 145   1          rs485.TX4_buf[0]  = MY_ADDR;                //Addr
 146   1          rs485.TX4_buf[1]  = 0x04;                   //Fun
 147   1          rs485.TX4_buf[2]  = modbus.byte_cnt;        //Byte Count
 148   1      
 149   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
 150   1          {
 151   2              /*    每次循环前初始化byte_info                 */
 152   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
 153   2              switch (i)
 154   2              {
 155   3                  /*  30001  热电偶温度                       */
 156   3                  case 0x00:
 157   3                      modbus.byte_info_H = 0X00; 
 158   3                      modbus.byte_info_L = slave_04.tc_temp; 
 159   3      
 160   3                      break;
 161   3      
 162   3                  default:
 163   3                      break;
 164   3              }
 165   2              rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 166   2              rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 167   2          }
 168   1          slave_to_master(0x04,3 + modbus.byte_cnt);
 169   1      }
 170          
 171          /**
 172           * @brief 写单个输出寄存器  06
 173           *
 174           * @param   void
 175           *
 176           * @return  void 
 177          **/
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        09/24/2025 09:13:48 PAGE 4   

 178          void Modbus_Fun6( void )
 179          {
 180   1          switch (rs485.RX4_buf[3])
 181   1          {
 182   2              /*  40001 热电偶预加热和加热停止温度    */
 183   2              case 0x00:           
 184   2                  slave_06.tc_preheat_temp = rs485.RX4_buf[4];                    
 185   2                  slave_06.tc_alarm_temp   = rs485.RX4_buf[5];      
 186   2      
 187   2                  break;  
 188   2      
 189   2              /*  40002 撒粉功率                      */
 190   2              case 0x01:                 
 191   2                  slave_06.sf_level   = rs485.RX4_buf[5];   
 192   2      
 193   2                  break;
 194   2      
 195   2              /*  40003 抖粉功率                      */    
 196   2              case 0x02:                                                         
 197   2                  slave_06.df_level   = rs485.RX4_buf[5];   
 198   2      
 199   2                  break;
 200   2                  
 201   2              /*  40004 吸风开关                      */
 202   2              case 0x03:
 203   2                  slave_06.iw2_switch   = rs485.RX4_buf[4];                                                     
             -    
 204   2                  slave_06.iw1_switch   = rs485.RX4_buf[5];   
 205   2                  IW_ctrl();
 206   2      
 207   2                  break;
 208   2      
 209   2              /*  40005 冷风开关                      */
 210   2              case 0x04:                                         
 211   2                  slave_06.cw_switch   = rs485.RX4_buf[5];
 212   2                  CW_ctrl();
 213   2      
 214   2                  break;
 215   2      
 216   2              /*  40006 收料开关                      */
 217   2              case 0x05:                                         
 218   2                  slave_06.mr_switch   = rs485.RX4_buf[5];  
 219   2                  MR_ctrl();
 220   2      
 221   2                  break;
 222   2      
 223   2              /*  40007 同步开关                      */
 224   2              case 0x06:                                         
 225   2                  slave_06.sync_switch   = rs485.RX4_buf[5];  
 226   2      
 227   2                  break;
 228   2      
 229   2              default:
 230   2                  break;   
 231   2          }
 232   1      
 233   1          slave_to_master(0x06,8);
 234   1      
 235   1          eeprom_data_record();
 236   1      }
 237          
 238          
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        09/24/2025 09:13:48 PAGE 5   

 239          /**
 240           * @brief 从机回复主机
 241           *  
 242           * @param   code_num:功能码       
 243           * @param   length:数据长度        
 244           * 
 245            @return  crc16:crc校验的值 2byte
 246           */
 247          void slave_to_master(uint8_t code_num,uint8_t length)
 248          {
 249   1          uint16_t crc;
 250   1      
 251   1          switch (code_num)
 252   1          {
 253   2              case 0x03:
 254   2                  crc = MODBUS_CRC16(rs485.TX4_buf,length);
 255   2      
 256   2                  rs485.TX4_buf[length+1] = crc;             //CRC H
 257   2                  rs485.TX4_buf[length] = crc>>8;            //CRC L
 258   2      
 259   2                  rs485.TX4_send_bytelength = length + 2;
 260   2                  
 261   2                  break;
 262   2              case 0x04:
 263   2                  crc = MODBUS_CRC16(rs485.TX4_buf,length);
 264   2      
 265   2                  rs485.TX4_buf[length+1] = crc;              //CRC H
 266   2                  rs485.TX4_buf[length] = crc>>8;             //CRC L
 267   2      
 268   2                  rs485.TX4_send_bytelength = length + 2;
 269   2                  
 270   2                  break;    
 271   2      
 272   2              case 0x06:
 273   2                  memcpy(rs485.TX4_buf,rs485.RX4_buf,8);
 274   2      
 275   2                  rs485.TX4_send_bytelength = length;
 276   2                  
 277   2                  break;    
 278   2      
 279   2              case 0x10:
 280   2                  memcpy(rs485.TX4_buf,rs485.RX4_buf,6);
 281   2              
 282   2                  crc = MODBUS_CRC16(rs485.TX4_buf,6);
 283   2      
 284   2                  rs485.TX4_buf[7] = crc;                 //CRC H
 285   2                  rs485.TX4_buf[6] = crc>>8;              //CRC L
 286   2              
 287   2                  rs485.TX4_send_bytelength = length;
 288   2                  
 289   2                  break; 
 290   2      
 291   2              default:
 292   2                  break;
 293   2          }
 294   1      
 295   1          DR4 = 1;                                 //485可以发送
 296   1          delay_ms(2);
 297   1          S4CON |= S4TI;                              //开始发送
 298   1          delay_ms(1);
 299   1      }
 300          
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        09/24/2025 09:13:48 PAGE 6   

 301          
 302          /**
 303           * @brief crc校验函数
 304           * 
 305           * @param   buf：  Address(1 byte) +Funtion(1 byte) ）+Data(n byte)   
 306           * @param   length:数据长度           
 307           * 
 308            @return  crc16:crc校验的值 2byte
 309           */
 310          uint16_t MODBUS_CRC16(uint8_t *buf, uint8_t length)
 311          {
 312   1        uint8_t i;
 313   1        uint16_t  crc16;
 314   1      
 315   1          /* 1, 预置16位CRC寄存器为0xffff（即全为1）                          */
 316   1        crc16 = 0xffff; 
 317   1      
 318   1        do
 319   1        {
 320   2              /* 2, 把8位数据与16位CRC寄存器的低位相异或，把结果放于CRC寄存器     */    
             -    
 321   2          crc16 ^= (uint16_t)*buf;    //
 322   2          for(i=0; i<8; i++)    
 323   2          {
 324   3                  /* 3, 如果最低位为1，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位 再异或0xA001    */
 325   3            if(crc16 & 1)
 326   3                  {
 327   4                      crc16 = (crc16 >> 1) ^ 0xA001;
 328   4                  }
 329   3                  /* 4, 如果最低位为0，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位                */
 330   3                  else
 331   3                  {
 332   4                      crc16 >>= 1;
 333   4                  }   
 334   3          }
 335   2          buf++;
 336   2        }while(--length != 0);
 337   1      
 338   1        return  (crc16);
 339   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    989    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
